{"/home/travis/build/npmtest/node-npmtest-angoose/test.js":"/* istanbul instrument in package npmtest_angoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angoose/lib.npmtest_angoose.js":"/* istanbul instrument in package npmtest_angoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_angoose = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_angoose = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-angoose/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-angoose && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_angoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_angoose\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_angoose.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_angoose.rollup.js'] =\n            local.assetsDict['/assets.npmtest_angoose.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_angoose.__dirname +\n                    '/lib.npmtest_angoose.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/angoose.js":"// Angoose main module\n//  \n//      var angoose = require(\"angoose\");\n//      angoose.init(expressApp, { })\n//\nvar ROOT = process.cwd();\nvar path= require(\"path\"),traverse = require(\"traverse\"),hooks= require(\"hooks\"), Q = require(\"q\");\nvar fs = require(\"fs\"),logging = require(\"log4js\"), _ =require(\"underscore\");\n\nvar Pipeline = require('./Pipeline');\nvar Bundle = require(\"./Bundle\");\n  \nvar pjson = require('../package.json'), toolbox = require(\"./util/toolbox\");\nvar async = toolbox.async, domain=require(\"domain\");\nvar logger = logging.getLogger('angoose');\nlogger.setLevel('INFO');\nvar domainLogger = logging.getLogger('angoose-domain');\ndomainLogger.setLevel('INFO');\nvar DEFAULT_OPTIONS = { \n    'core-extensions':['angoose-mongoose'],\n    'url-prefix':'/angoose',\n    'client-file': ROOT+'/angoose-client-generated.js',\n    'module-dirs': './models',\n    'mongo-opts':'localhost:27017/test',\n    'logging':'INFO'\n}\n/** Variables */\nvar options = {};\nvar beans = {}; /** this holds all Angoose classes*/\n\n// ### API References\n\n// ** init(app, options) **\n//\n// Initialize Angoose. This function should be called in the express app\n//  \n// * @app: Express app, for now\n// * @options: Angoose settings:\n//     - module-dirs, optional, default to ./models\n//     - url-prefix, optional, default to /angoose\n//     - mongo-opts, optional. Provide this if you want Angoose to make the connection \n// \nfunction init(app, conf, force) {\n    if(this.initialized && !force) return;\n    \n    //beans = {};\n    /** configurations*/\n    initialConfig(conf);\n    \n    logger.info(\"Angoose Initialization Start\");\n    logger.trace(\"Init options:\", conf);\n    \n    /** connect to Mongo if necessary */\n    connectMongo(options);\n    \n    /** register initial hooks */\n    //registerHooks();        \n    \n    /** pre-load models/services from directories */\n    harvestModules(options);\n    \n    /** plugin extensions */\n    hookupExtensions();\n    \n    /** build client side schemas */\n    generateClient();\n\n    /** configure the routes for handling RMI and client loading*/\n    /**@todo: middleware*/\n    configureRoutes(app, options);   \n  \n    logger.info(\"Angoose Initialization Complete\");\n} \n \n// ** module(name, function_or_object) **\n//\n// Retrieve an Angoose module or register one\n//\n// If only one argument, name is provided, returns the registered module with that name. This form is same as `angoose.getClass()`\n//\n// If two arguments are provided, register the function/object as Angular module under that name.\n//\n\nfunction lookupOrRegister(name, target){\n    if(arguments.length == 0) return null;\n    if(arguments.length == 1) return getClass(name);\n    if(arguments.length == 2) return registerClass(name, target);\n}\n\nfunction registerExtension(name, module){\n     if( typeof(name) =='object' ) \n        name.isExtension = true;\n     else \n        name = {name: name, isExtension:true}\n     return registerClass(name,module);      \n}\n\nfunction hasModule(name){\n    return beans[name] ? true : false; \n}\n\nfunction getClass(name){\n    name = toolbox.camelcase(name);\n    if(!beans[name]) throw \"Class '\"+ name+\"' is not found. Check log to see if class is loaded successfully \"\n    return beans[name];  \n}\n\n// register module with angoose so it knows to publish it\nfunction registerClass(nameOrOpts, claz){\n    var opts = typeof(nameOrOpts) == 'object'?nameOrOpts: {name: nameOrOpts};\n    var className = opts.name;\n    if(!className) throw \"Missing module name: \"+ className\n    if(beans[className])\n        logger.warn(\"Overriding existing bean: \", className);\n    if(claz._angoosemeta && (claz._angoosemeta.baseClass == 'Service' || claz._angoosemeta.baseClass == 'Model') ){\n        // already mixed\n    }\n    else{\n        if(typeof(claz) === 'function' && claz.schema  && claz.modelName )\n            opts.baseClass = 'Model';\n        else if(claz instanceof getMongoose().Schema){\n            opts.baseClass = 'Model';\n            claz = getMongoose().model(className, claz);\n        }\n        else\n            opts.baseClass = 'Service';\n        angoose.Remotable.mixin(opts, claz);\n    }\n    _.extend(claz._angoosemeta, nameOrOpts);\n    \n    beans[className] = claz;\n    //if(!nameOrOpts.isExtension)\n        logger.debug(\"Registered module\", claz._angoosemeta.baseClass, className);\n    return claz;\n    // if(claz._angoosemeta && (claz._angoosemeta.baseClass == 'Service' || claz._angoosemeta.baseClass == 'Model') ){\n//         \n    // }\n    // else{\n        // throw \"Invalid class: must be a Model or Service class: \" + claz;\n    // }\n}\n\n// ** getContext() **\n//\n// Returns the current execution context. \n//  \n// This methods returns a Context object which allows you to get a reference to the current request object \n// and/or login user's Principal object. If the callee isn't inside Angoose execution context, an error will \n// be thrown. See [Context](Context.html) for more.\nfunction getContext(){\n    \n    if(!domain.active || !domain.active.context){\n        if(this.mockContext) return this.mockContext\n        \n        logger.error(\"getContext called but no active domain\", domain.active);\n        logger.error(\"Caller is \",   arguments.callee && arguments.callee.caller && arguments.callee.caller.name, arguments.callee && arguments.callee.caller );\n        throw \"Context not available. This may happen if the code was not originated by Angoose\";  \n    } \n    \n    return domain.active.context;\n} \n\nfunction setContext(ctx){\n    this.mockContext = ctx;\n}\nfunction testContext(name){\n    \n    if(!domain.active){\n        domainLogger.debug(\"-------------------------------------- TEST-CONTEXT \", name, \"NO ACTIVE DOMAIN\");\n        return;\n    }\n    if(!domain.active.context){\n        domainLogger.debug(\"---------------------------------------TEST-CONTEXT \", name, \"NO CONTEXT in active domain\");\n        return;\n    }\n    domainLogger.debug(\"-------------------------------------- TEST-CONTEXT \", name, \"  OK \");\n}\n\n// ** defer() **\n//\n// Convenience wrapper for `Q.defer()`, returns a deferred object\n//\nfunction defer(){\n    return Q.defer();\n}\n \n \nfunction configureRoutes(app, options){\n    if(!app){\n        logger.warn(\"app not provided, RMI functionality is disabled\");   \n        return;\n    }\n    /** this is the main RMI endpoint */\n    app.post(options['url-prefix']+\"/rmi/:model/:method\", Pipeline.accept);\n    /** @todo: use static serving to enable cache //app.get(\"/angoose/AngooseClient.js\", express.static(options.clientFile)); */\n    app.get(options['url-prefix']+\"/angoose-client.js\", function(req, res){\n        logger.debug(\"Handling AngooseClinet.js load request\");\n        var filename = options['client-file'] ;  \n        var content = fs.readFileSync(filename , 'ascii');\n        res.set('Content-Type', 'application/javascript');\n        res.send(200,   content );  \n    });\n    app.get(options['url-prefix']+\"/angoose-client.min.js\", function(req, res){\n        logger.debug(\"Handling AngooseClinet.js.min.js load request\");\n        var filename = options['client-file']+\".min.js\" ;\n        var content = fs.readFileSync(filename , 'ascii');\n        res.set('Content-Type', 'application/javascript');\n        res.send(200,   content );\n    });\n    app.get(options['url-prefix']+\"/angoose-client.js.map\", function(req, res){\n        logger.debug(\"Handling AngooseClinet.js.min.map load request\");\n        var filename = options['client-file']+\".min.map\" ;\n        var content = fs.readFileSync(filename , 'ascii');\n        res.set('Content-Type', 'application/octet-stream');\n        res.send(200,   content );\n    });\n}\n\n    \n\n\n//** bind(func) **\n//\n// Bind the async callback function with the active domain so we dont' lose the context.\n//\n// Necessary for Mongoose (and maybe other async modules) callbacks. \n//      \nfunction inContext(fn){\n    /** there is a known issue with CLS that it does not work with MongoDB, \n     * needs to bind the callback with the CLS context \n     * https://github.com/othiym23/node-continuation-local-storage/issues/6\n     * */\n    if(domain.active) return domain.active.bind(fn);\n    return fn;\n}\n\nfunction scanModelFiles(dirs){\n    var dirs = _.isArray(dirs)? dirs: [dirs];\n    var files = [];\n    files.push(path.resolve( __dirname , '../models/SampleUser.js')); // sample model\n    \n    function scanDir(dirname){\n        if(!dirname ||   dirname.indexOf(\"node_modules\")>=0) return;\n        logger.debug(\"Scanning directory for modules: \", dirname);\n        if(fs.existsSync(path.resolve(dirname, 'index.js'))){\n            files.push(path.resolve(dirname, 'index.js') );\n            return;\n        }\n        fs.readdirSync( dirname  ).forEach(function(file) {\n            var fullpath = path.resolve(dirname,file);\n            if(! fs.statSync(fullpath).isFile()) scanDir( fullpath );\n            else if (file.match(/.+\\.js/g) !== null) {\n                files.push(fullpath);\n            }\n        });\n    }\n    dirs.forEach(function(dirname){\n        scanDir(dirname);\n    });\n    return files;\n}\n\nfunction harvestModules(options){\n    logger.debug(\"Harvesting modules\");\n    \n    logger.debug(\"Loading all extensions\");\n    var extensions = options['core-extensions'].concat(options.extensions || []);\n    var extensionFiles = _.map(extensions, function(ext){\n        var coreExtension = path.resolve(__dirname,  \"../extensions/\"+ ext);\n        if(typeof(ext) == \"string\" && \n                ( fs.existsSync( coreExtension +\".js\") ||  fs.existsSync(coreExtension)   ) ){\n            logger.trace(\"Load core extension\", ext);\n            return coreExtension\n        }\n        return ext;\n    });\n    \n    logger.debug(\"Loading all modules\");\n    \n    var files = extensionFiles.concat(  scanModelFiles( options.modelDir || options['module-dirs'] ) );\n    files.forEach(function(file) {\n            try{\n                if(typeof(file === 'string')){\n                    logger.trace(\"Loading module file\", file);\n                    require(file);\n                }\n            }\n            catch(ex){\n                 logger.error(\"Skipping file \", file, \" due to error: \", ex);\n            }\n    });   \n    logger.debug(\"Adding all mongoose models\");\n    _.each(getMongoose().modelNames(), function(modelName){\n        if(!hasModule(modelName)){\n            registerClass( modelName,  getMongoose().model(modelName));\n        } \n    });\n};\n// ** geneateClient() **\n//\n// Generates the client file to be served as the contents of resource `/angoose/angoose-client.js` \nfunction generateClient(){\n    logger.debug(\"Generating angoose client file: \");\n    var bundle = new Bundle();\n    var client = {};\n    bundle.generateClient(client);\n    var filename = angoose.config()['client-file'];\n    writeToFile(filename, client.source)\n    //compressFile(filename, client.source);\n    logger.info(\"Generated  angoose client file: \", filename);\n    return client.source;\n}\n\nfunction compressFile(filename,source){\n    var UglifyJS = require(\"uglify-js\");\n    var mapFile=filename+\".map\";\n    var minFile=filename+\".min.js\";\n    var result = UglifyJS.minify(source, {fromString:true,outSourceMap:mapFile});\n    var map=JSON.parse(result.map);\n    map.sources=[\"angoose-client.js\"]\n    var code = '//# sourceMappingURL=angoose-client.js.map\\n'+result.code;\n    writeToFile(minFile,code);\n    writeToFile(mapFile,JSON.stringify(map));\n}\nfunction writeToFile(filename, content){\n    \n    if(filename.indexOf(\"/\")>=0){\n        // make sure directory exists\n        var outputDir = filename.replace(/^(.*)\\/[^\\/]+$/, \"$1\");\n        if(outputDir && !fs.existsSync){\n            logger.debug(\"Creating dir\", outputDir)\n            fs.mkdirSync(outputDir);    \n        }\n    }\n    fs.writeFileSync(filename, content);\n    logger.debug(\"Generated the client file:\", filename);\n}\n/**\n * This is mostly used by tests\n */\nfunction getClient(forceGenerate){\n    if(!angoose.initialized ||  forceGenerate)\n        generateClient();\n    return require(options['client-file']);\n}\nfunction connectMongo(options){\n    var mongoose = getMongoose();\n    if(mongoose.connection && mongoose.connection.readyState > 0 ){\n        logger.debug(\"Found Mongoose connection\"); \n        return;\n    }  \n    try{\n        logger.debug(\"Connecting to mongodb\", options.mongo_opts || options['mongo-opts'])\n        mongoose.connect( (options.mongo_opts || options['mongo-opts']) , function(err){\n            if(err) logger.debug(\"Error connecting to Mongo:\", err)\n            else logger.debug(\"Connected to MongoDB\")\n        }); /**@todo: handle complex connection options*/\n        //mongoose.connection.on('error', console.error.bind(console, 'connection error:'));\n    }\n    catch(err){\n        logger.debug(\"mngoose connection error\", err)\n    }\n}\n\nfunction service(nameOpts, proto){\n    logger.debug(\"creating service \", nameOpts, typeof(proto));\n    var opts = typeof(nameOpts) == 'string'? {name: nameOpts}: nameOpts;\n    if(!opts.name) throw \"Service name must be provided.\";\n    proto = proto || {}; \n    return angoose.Service.extend(proto, opts );\n}\nfunction getMongoose(){\n    angoose.mongoose = angoose.mongoose || options.mongoose;\n    if(!angoose.mongoose){\n        try{\n            angoose.mongoose =  module.parent.require('mongoose');\n            logger.debug(\"Required mongoose from parent\")    \n        }\n        catch(err){\n            logger.debug(\"No mongoose in parent module\");\n            angoose.mongoose = require(\"mongoose\");\n        }\n        \n    }  \n    return angoose.mongoose;\n}\nfunction noop(){};\n\n\nfunction hookupExtensions(){\n    logger.debug(\"Searching Extensions in Modules\");\n    toolbox.removeHookPoints(Pipeline);\n    Bundle.initHooks();\n    Object.keys(beans).forEach(function(bname){\n        var bean = beans[bname];\n        if(!bean._angoosemeta.isExtension) return;\n        logger.debug(\"Loading extension\", bname);\n        bean.config('visibility', false);\n        registerHook(bean, bname);\n    });\n}\n\nfunction registerHook(middleware, name){\n    if(!middleware) return;\n    var hooks = require(\"hooks\");\n    // if(typeof(middleware) == 'string'){\n        // try{\n            // if(fs.existsSync(path.resolve(__dirname,  \"../extensions/\"+ middleware+\".js\"))){\n                // logger.debug(\"loading built-in extension\", middleware);\n                // middleware = require(\"../extensions/\"+ middleware);\n            // }\n            // else\n                // middleware = require(middleware);\n        // }\n        // catch(err){\n            // logger.error(\"Require middleware\", middleware, \" failed\", err);\n        // }\n    // }\n    //if(typeof(middleware)!='object') throw new Error(\"Angoose middleware is not an object: \" + middleware);\n    //if(!middleware.name) throw new Error(\"Middleware must have a name\");\n    //var name = middleware.name;\n    \n    Object.keys(middleware).forEach(function(key){\n        if(!middleware.hasOwnProperty(key)) return;\n        var func = middleware[key]; \n        if(typeof (func)!='function') return;\n        \n        var hookType = null;\n        var method = null;\n        if(key.indexOf('pre') == 0){\n            hookType = 'pre';\n            method =  key.substring('pre'.length);\n        }\n        else if(key.indexOf('before') == 0){\n            hookType = 'pre';\n            method =  key.substring('before'.length);\n        }\n        else if(key.indexOf('post') == 0){\n            hookType = 'post';\n            method =  key.substring('post'.length);\n        }\n        else if(key.indexOf('after') == 0){\n            hookType = 'post';\n            method =  key.substring('after'.length);\n        }\n        if(!hookType || !method){\n            return;\n        }\n        method = method.substring(0,1).toLowerCase() + method.substring(1);\n        if(Pipeline.prototype[method]){\n            logger.debug(\"setting up extension point: \", name, hookType, method) \n            Pipeline[hookType](method, func);\n        }\n        else if(!Bundle[hookType](method, func)){\n            logger.error(\"Unknown extension point: \", key);\n        }\n    });\n    \n    logger.info(\"Registered  Extension\", name);\n}\n\n\n// function registerHooks(){\n    // logger.debug(\"Registering extensions\");\n    // toolbox.removeHookPoints(Pipeline);\n    // toolbox.removeHookPoints(ClientSchema);\n//     \n    // var extensions = options['core-extensions'].concat(   options.hooks || options.extensions || []);\n    // if(extensions){\n        // var hooks = Array.isArray(extensions)? extensions:[extensions];\n        // _.each(hooks, function(hook){\n            // // unregister first \n            // registerHook(hook);\n        // })\n    // }\n// }\n// function reload(module){\n    // var name = require.resolve(module);\n    // delete require.cache[name];\n    // return require(module);\n// }\n\nfunction getLogger(name){\n    name = name || 'angoose';\n    return require(\"log4js\").getLogger(name);\n}\n\nfunction initialConfig(conf){\n    options = _.extend({}, DEFAULT_OPTIONS);\n     \n    /** overrite default configurations */\n   Object.keys(conf).forEach(function(key){\n       toolbox.setter(options, key,  conf[key]); // this way we will allow \"forms.url.prefix\" type of configuration\n   }) \n    //_.extend(options, conf );\n    if(conf && conf.urlPrefix)  options['url-prefix'] = conf.urlPrefix;\n    if(conf && conf.modelDir)  options['module-dirs'] = conf.modelDir;\n    if(conf && conf.mongo_opts)  options['mongo-opts'] = conf.mongo_opts;\n    if(conf && conf.clientFile)  options['client-file'] = conf.clientFile;\n    logger.setLevel( options.logging || 'INFO' );\n    \n    angoose.initialized = true;\n}\n/**\n *  Set or get configurations.\n * \n *  Usage:\n * \n *   config()    get the whole configuration object\n *   config(object)    set the configuration by merging the configuration options\n *   config(path)  get the configuration value at path. \n *   config(path, val) set the value at path.\n */\nfunction config(path, val){\n    if(!path) return options; /**@todo: probably a deep copy */\n    if(!angoose.initialized && typeof(path) == 'string') throw \"Cannot call config(\" + path+\") before angoose is intialized\";\n    //if(angoose.initialized && typeof(conf) == 'object') throw \"Cannot config Angoose after startup\";\n    \n    if(typeof (path) === 'string'){\n         if(val === undefined)\n            return toolbox.getter(options, path);\n         toolbox.setter(options, path, val);\n    }\n    \n    if(typeof(path) === 'object'){\n        // deep merge\n        options = toolbox.merge(options, path);\n\n    }\n}\n\nfunction moduleNames(){\n    return Object.keys(beans);\n}\nfunction angoose(){\n    return lookupOrRegister.apply(null, arguments)\n}\n\n\nfunction bootstrap(){\n    \n    /** statics */\n    angoose.Remotable = require(\"./Remotable\");\n    angoose.Principal = require(\"./Principal\");\n    angoose.Context = require(\"./Context\");\n    angoose.Model = require(\"./Model\");\n    angoose.Bundle = Bundle;\n    \n    angoose.init = init;\n    angoose.getClass = getClass;\n    angoose.getContext = getContext;\n    angoose.testContext = testContext;\n    angoose.generateClient = generateClient; /** testing only */\n    angoose.service = service;\n    angoose.getMongoose = getMongoose;\n    angoose.rmiAccept = Pipeline.accept; /** for unit test purpose*/\n    angoose.setContext = setContext; // for test\n    angoose.execute = Pipeline.execute;\n    \n    /** public API */\n    angoose.Model = require(\"./Model\");\n    angoose.Service = require(\"./Service\");\n    angoose.defer = defer;\n    angoose.inContext = inContext;\n    angoose.config = config;\n    angoose.getLogger = getLogger;\n    angoose.hasModule = hasModule;\n    /**@since 0.2.13 */\n    angoose.bind = inContext;\n    angoose.client = getClient;\n    \n    angoose.moduleNames = moduleNames;\n     \n    angoose.module = lookupOrRegister\n    angoose.extension = registerExtension;\n    angoose.mongoose = getMongoose();\n    //getMongoose();\n}\n\nbootstrap();\n\nmodule.exports =  angoose;\n\n\n \n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Pipeline.js":"var path= require(\"path\"),traverse = require(\"traverse\"),hooks= require(\"hooks\"), Q = require(\"q\");\nvar fs = require(\"fs\"),logging = require(\"log4js\"), _ =require(\"underscore\");\nvar domain = require(\"domain\");\nvar toolbox = require(\"./util/toolbox\");\nvar async = toolbox.async;\nvar logger = logging.getLogger('angoose');\nvar Context = require(\"./Context\");\nvar Exception = require(\"./Exception\");\n\n/**@todo: move to mongoose plugin */\ntoolbox.patchMongoCallback();\n\nfunction Pipeline(){}\nfor (var k in hooks) { Pipeline[k] = hooks[k];}\n\nvar proto = Pipeline.prototype;\n    \nproto.authorize= function authroize(invocation, authorizeBack){\n    logger.debug(\"STEP 100: pipline.authorize\");\n    \n    if(invocation.allowed !== undefined) authorizeBack && authorizeBack();\n    /** default implementation always grant access */\n    var defaultMode = angoose().config()['authorization-mode'];\n    invocation.allowed =  (defaultMode !== 'deny-all');\n    authorizeBack && authorizeBack();\n}\n\n\nproto.resolveTarget = function resolveTarget(invocation,  resolveBack){\n    logger.debug(\"STEP 200: pipline.resolveTarget\");\n    /**logger.debug(\"Preparing target from JSON\");*/\n\n    if(invocation.target){\n        logger.debug(\"Skipping default: resolveTarget\");\n        return resolveBack();\n    } \n    \n    if(!invocation.static && typeof(invocation.instance) != 'object') \n        return resolveBack(  new Error(\"Missing invocation instance property\" ));\n           \n    var modelClass = angoose().getClass( invocation.clazz );\n    if(invocation.static){ \n        invocation.target = modelClass;\n        return resolveBack();\n    }\n    \n    invocation.target = new modelClass(invocation.instance);\n    return resolveBack( ); \n}\n \nproto.resolveArguments = function resolveArguments(invocation, resolveArgBack){\n    logger.debug(\"STEP 300: pipline.resolveArguments\");         \n    //async(resolveArgBack)(false, invocation.args);\n    if(invocation.arguments !== undefined){\n        logger.debug(\"Skipping default: resolveArguments\");\n        return resolveArgBack();\n    }\n    invocation.arguments = invocation.args;\n    resolveArgBack ();\n}        \n\nproto.invoke = function invoke(invocation , invokeBack){\n    //logger.debug(\"STEP 400: pipline.invoke\");         \n    if(invocation.results !== undefined){\n        logger.debug(\"Skipping default: invoke\");\n        return invokeBack();\n    }\n    var method =  invocation.method;  \n    var seqnum = invocation.seqnumber;\n    var target = invocation.target;\n    var args = invocation.arguments;\n    \n    var useCallback  = false;\n    \n    function callbackHandler(err, result){\n        /** converting to Q promise */\n        logger.trace(\"In invoke callback handler #\"+seqnum, err);\n        if(err){\n            logger.debug(\"Method invocation returned error:\", err);\n            //return deferred.reject(err);\n            err = err instanceof Error? err: new Error(err);\n            return invokeBack( err);\n        }\n        logger.trace(\"Method invocation result:\", result)\n        invocation.result = result;\n        invokeBack();\n    }\n    if( invocation.method == 'save' && args.indexOf(\"$callback\")<0  ){\n        args.push('$callback'); // hack for now\n    }\n    \n    useCallback =  injectDependencies(target[method], args,  callbackHandler);\n    logger.debug(\"invoking method \",  method, \"arguments\", args );\n    \n    if(!target[method]) return invokeBack(new Error('Method '+ method+\" is not defined on module \"+ invocation.clazz));\n    var ret = target[method].apply(target,  args);\n    \n    logger.trace(\"invoking result\", ret);\n    if(ret instanceof Error) return callbackHandler(ret);\n    \n    if(Q.isPromise(ret) || (ret && typeof(ret.done) == 'function')){\n        ret.done(function(result){\n            callbackHandler(false, result);\n        }, function(err){\n            callbackHandler(err);\n        }); \n    }\n    else if(!useCallback || ret !== undefined) {\n        /** if method returns data directly or returned undefined */\n        return callbackHandler(false, ret); \n    }\n}; /**  end invoke */\n\n\nproto.redact = function redact(invocation, redactBack){\n    logger.debug(\"STEP 500: pipline.redact\");\n    if(invocation.redacted !== undefined){\n        logger.debug(\"Skipping default: redact\");\n        return redactBack();\n    }\n    invocation.redacted = invocation.result;\n    redactBack();\n} \n\nproto.pack = function pack(invocation,  packBack){\n    logger.debug(\"STEP 600: pipline.pack\");\n    if(invocation.packed !== undefined){\n        logger.debug(\"Skipping default: pack\");\n        return packBack();\n    }\n    \n    var target = invocation.target;\n    var redacted = invocation.redacted;\n    var valueType = getValueType(redacted);  /** model, models, object, string*/\n    var retdata = { success:true, \n                    exception:null, \n                    retval:redacted,\n                    datatype: valueType, \n                    seqnumber:invocation.seqnumber \n    };\n    if( !invocation.static && (! _.isEqual(target.toJSON(), invocation.target))) \n    {\n        /** return the instance data if it has changed */                        \n        retdata.instance = target.toJSON();\n    }\n    invocation.packed = retdata;\n    packBack();    \n}\n\nproto.formatError = function formatError(invocation, formatBack){\n    if(invocation.packed) return formatBack();\n    var ex = invocation.exception;\n    ex.invocation = invocation.clazz +\".\"+ invocation.method;\n    ex.seqnumber = invocation.seqnumber;\n    invocation.packed = {\n         success:false,\n         exception:ex,\n         seqnumber: invocation.seqnumber\n    }\n    formatBack();\n}\nfunction getValueType(obj){\n    if(!obj || typeof(obj) == 'string') return 'string';\n    return 'object';\n}\n//hookIt('authorize', proto.authorize);\n\nfunction injectDependencies(func, args, callback ){\n    \n    var declaredArguments = toolbox.parseDeclaredArguments(func);\n    declaredArguments = declaredArguments.replace(/\\s+/g, \"\").split(\",\");\n    logger.trace(\"injectDependencies() declaredArguments: \", declaredArguments, \"provided args:\", args);\n    var useCallback = false;\n    var len = args.length > declaredArguments.length? args.length:declaredArguments.length;\n    for(var i=0;i< len ;i++){ // this is problematic: functions may be wrapped and lost the arguments data\n        /** if client did not provide enough number of arguments, we fill it with null*/\n        if(typeof( args[i]) == 'undefined')\n            args[i] = undefined;\n        else if(args[i] === \"$callback\"){\n            useCallback = true;    \n            args[i] = callback;        \n        }\n        switch(declaredArguments[i]){\n            case '$callback':\n                logger.debug(\"Injecting callback handler\");\n                args[i] = callback;\n                useCallback = true;\n                break;\n             case '$context':\n                logger.debug(\"Injecting angoose context\");\n                args[i] = angoose().getContext();\n                break;\n             default:\n                break; \n        } \n    } \n    return useCallback;\n}\n\nfunction angoose(){\n    return require(\"./angoose\");\n}\n\n\n/**\n * Main execution method\n * \n * @param invocation Invocation object\n */\nPipeline.execute = function(ctx, invocation, callback){\n        ['allowed', 'target', 'arguments','result','redacted'].forEach(function(key){\n            delete invocation[key];\n        });\n    \n        var dmain = domain.create();\n        dmain.context = ctx;\n        //var excutionStorage = storageFactory.createNamespace(\"angoose\");\n        /** here comes the main body of the processing */\n        dmain.run(function(){\n                var pipeline = new Pipeline();\n                var seqnum = invocation.seqnumber;\n                var sent = false;\n                logger.debug(\"------ BEGIN RMI #\", seqnum, invocation.clazz, invocation.method );\n                logger.trace(\"Invocation object: \",invocation);\n                //invocation.method = req.params.method;  /** method must be part of the path for routes permission etc */\n                ctx.seqnum = seqnum;\n                ctx.invocation = invocation;\n                 \n                function handleError(err, exName){\n                    if(sent){\n                        logger.debug(\"Response already sent\")\n                        return;  \n                    } \n                    /**@todo: err may cause Circular issue when converting to JSON */\n                    var ex = new Exception(err, exName);\n                    invocation.exception = ex;\n                    \n                    pipeline.formatError(invocation, function(er){\n                        logger.debug(\"====== END RMI with Error  #\", seqnum,  ex);\n                        callback(invocation.packed);\n                        sent  = true;    \n                    });\n                }\n                dmain.on('error',  function uncaught(ex){\n                    logger.error(\"Uncaught error in invocation #\"+seqnum, ex);\n                    /**@todo: restart server if too many errors */\n                    handleError(  \"Unexpected Server Error\", 'RuntimeError');\n                });\n                \n                /** setting execution context */\n                var sent = false;\n                 \n                var modelName = invocation.clazz;\n                var seqnum = invocation.seqnumber;\n                //excutionStorage.set(\"context\", ctx);\n                pipeline.authorize(invocation,   function(err){\n                    if(err) return handleError(err);\n                    if(! invocation.allowed) return handleError(\"Access Denied\", \"AuthError\");\n                    \n                    pipeline.resolveTarget(invocation,   function(err){\n                        if(err) return handleError(err);\n                        \n                        if(!invocation.target) return handleError(\"Target not resolved.\", \"ModuleNotFoundError\");\n                        \n                        pipeline.resolveArguments(invocation,function(err){\n                            if(err) return handleError(err);\n                            \n                            if(!invocation.arguments) return handleError(\"Arguments not resolved.\");\n                            pipeline.invoke(invocation, function(ex){\n                                \n                                if(ex) return handleError(ex);\n                                pipeline.redact(invocation, function(err){\n                                    if(err) return handleError(err);\n                                    pipeline.pack(invocation, function(err){\n                                        if(err) return handleError(err);\n                                        //res.send(200, packedData);\n                                        callback(invocation.packed);\n                                        sent = true;    \n                                        logger.debug(\"====== END RMI Succeeded #\", seqnum);\n                                        if(Array.isArray(invocation.packed && invocation.packed.retval) && invocation.packed.retval.length>0){\n                                            logger.trace(\"Response is an array with length:\",  invocation.packed.retval.length, \"First element:\",invocation.packed.retval[0] );    \n                                        }\n                                        else logger.trace(\"Response data is \", invocation.packed);\n                                        \n                                    });    \n                                });\n                            });    \n                        });\n                    });\n                });\n                /** catch the strayed handling, returns error in 5 seconds if response not sent */\n               var tmout = setTimeout(function(){\n                   if(sent) return;\n                   \n                   var msg = \"Timeout occurred when processing call \"+invocation.clazz +\".\" + invocation.method;\n                   logger.error(msg,  seqnum);\n                   handleError(msg);\n                   //res.send(200, packError( {message: msg, value: msg, code:500 }, invocation.seqnumber ));\n               }, angoose().config().request_timeout || 5000);\n               tmout.unref();\n               \n        });/** end context closure */ \n}\n      \nPipeline.accept = function accept(req, res){\n    var invocation = decode(req.body);\n    var ctx = new  Context({request:req, response:res} )\n    Pipeline.execute(ctx, invocation, function(data){\n        // traverse(data).forEach(function(){\n            // //if(this.circular) this.remove(); // circular ref will cause JSON.stringify fail\n        // });\n        res.send(200, data);\n    });\n}\n\n\nPipeline.hookables = 'authorize,resolveTarget,resolveArguments,invoke,redact,pack,formatError'.split(\",\");\ntoolbox.addHookPoints(Pipeline);\nmodule.exports =  Pipeline;\n\n\n\n\nfunction decode(obj){\n    /** due to Angular HTTP library's stupidity, keys starting with $ are ignored. hence _mongo_$ to work around this*/\n    if(!obj || typeof obj != 'object') return obj;\n    if(Array.isArray(obj)){\n        for(var i=0;i<obj.length;i++){\n            obj[i] = decode(obj[i]);\n        };\n    }\n    else{\n        Object.keys(obj).forEach(function(key){\n            var val = decode(obj[key]);\n            if(key.indexOf('_mongo_$')==0){\n                delete obj[key];\n                key = key.substring(7)\n            }\n            obj[key] = val;\n        })\n    }\n    return obj;\n}\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/util/toolbox.js":"// ## Toolbax\n// \n// Utility functions\n\n\nvar _ = require(\"underscore\");\n\n\nexports.camelcase = function cammelcase(name, space){\n    // converting client-user to ClientUser \n    if(!name) return name;\n    var parts = name.split(\"-\");\n    name = \"\";\n    for(var i=0;i< parts.length;i++){\n        if(parts[i] && parts[i].length>0){\n            name = name && space ? name+\" \":name;\n            name+= parts[i].substring(0,1).toUpperCase() + parts[i].substring(1);\n        } \n    }\n    return name;\n}\n\nexports.decamelcase = function decamelcase(name){\n    // convert ClientUser to client-user \n    if(!name) return name;\n    var ret = \"\";\n    for(var i=0;i<name.length;i++){\n        var c = name.charAt(i);\n        if(c.toLowerCase() != c && ret.length>0) ret+=\"-\"\n        ret += c;\n    }\n    return ret.toLowerCase();\n}\n\n \n \n// **async**\n//\n// Wrap a function so that it is called asynchronously. \n// This is necessary to ensure a call back is always asynchronous.\nexports.async = function async(fn, scope){\n    return function(){\n        var args = arguments\n        process.nextTick(function(){\n            fn.apply(scope, args)    \n        })\n    }\n};\n\n\nexports.getter = function (doc, path){\n    if(!path || !doc) return undefined;\n     var   pieces = path.split('.');\n      var obj = doc;\n      for (var i = 0, l = pieces.length; i < l; i++) {\n        obj = undefined === obj || null === obj\n          ? undefined\n          : obj[pieces[i]];\n      }\n      return obj;\n}\n\nexports.setter = function(doc, path, val){\n    if(!path || !doc ) return;\n     var   pieces = path.split('.');\n      var obj = doc;\n      for (var i = 0, len = pieces.length; i < len; i++) {\n          if(i+1  == len ) // last one\n          {\n              obj[ pieces[i]] = val;\n              return;\n          }\n          obj[pieces[i]] = obj[pieces[i]] || {};\n          obj = obj[pieces[i]] || {};\n      }\n}\nexports.patchQ = function(){\n        \n    /** Workaround for Q module with CLS */\n    function matroshka(fn) {\n      var babushka = fn;\n      Object.keys(process.namespaces).forEach(function (name) {\n        babushka = process.namespaces[name].bind(babushka);\n      });\n    \n      return babushka;\n    }\n    function patchQueue() {\n      var Q = require('q');\n      var proto = Q && Q.makePromise && Q.makePromise.prototype;\n      function wrapperFunc(then) {\n        return function nsThen(fulfilled, rejected, progressed) {\n          if (typeof fulfilled === 'function') fulfilled = matroshka(fulfilled);\n          if (typeof rejected === 'function') rejected = matroshka(rejected);\n          if (typeof progressed === 'function') progressed = matroshka(progressed);\n          return then.call(this, fulfilled, rejected, progressed);\n        };\n      }\n      require(\"shimmer\").wrap(proto, 'then', wrapperFunc);\n      require(\"shimmer\").wrap(proto, 'done', wrapperFunc);\n    }\n    \n    patchQueue();\n\n};\n\nexports.patchMongoCallback = function(){\n\tvar mongodbs = [];\n\t\n\ttry{\n        mongodbs.push( require(process.cwd() + \"/node_modules/mongoose/node_modules/mongodb/lib/mongodb/db\").Db );\n    }\n    catch(err){\n    }\n\ttry{\n\t\tmongodbs.push( require(\"mongoose/node_modules/mongodb/lib/mongodb/db\").Db );\n\t}\n\tcatch(err){\n\t}\n\ttry{\n        mongodbs.push( require(\"mongodb/lib/mongodb/db\").Db );\n    }\n    catch(err){\n    }\n    try{\n        mongodbs.push( require(\"../mongodb/lib/mongodb/db\").Db );\n    }\n    catch(err){\n    }\n    \n\tfor(var i=0;i<mongodbs.length;i++){\n\t\tvar mongodb = mongodbs[i];\n\t\tmongodb.prototype._executeInsertCommand = bindMongoCallback(mongodb.prototype._executeInsertCommand);\n\t\tmongodb.prototype._executeQueryCommand = bindMongoCallback(mongodb.prototype._executeQueryCommand);\n\t\tmongodb.prototype._executeUpdateCommand = mongodb.prototype._executeInsertCommand ;\n\t\tmongodb.prototype._executeRemoveCommand = mongodb.prototype._executeInsertCommand ;\n\t}\n\tvar domain = require(\"domain\");\n\tfunction bindMongoCallback(fn){\n\t\treturn function(cmd, options, callback){\n\t\t\tif(domain.active){\n\t\t\t\tif(typeof(callback) ==='function') callback = domain.active.bind(callback);\n\t\t\t\telse if(!callback && typeof(options) === 'function') options = domain.active.bind(options);\n\t\t\t}\n\t\t\telse{\n\t\t\t    //console.error(\"DOMAIN LOST\", cmd.collectionName, cmd.query);\n\t\t\t}\n\t\t\tfn.call(this, cmd, options,callback  );\n\t\t};\n\t};\n\n};\n\nexports.bindCallback = function(scope, fn){\n    return function(){\n        var lastArg = arguments.length? arguments[arguments.length-1]: null;\n        if(typeof(lastArg) != 'function') return fn.apply(scope || this, arguments);\n        var domain =require(\"domain\");\n        if(domain.active){\n            arguments[arguments.length-1] = domain.active.bind(lastArg);\n        }\n        return fn.apply(scope || this, arguments);\n    }\n}\nexports.addHookPoints = function(clazz, hookables){\n    var hooks = require(\"hooks\");\n    hookables = hookables || clazz.hookables;\n    for (var k in hooks) { clazz[k] = hooks[k];}\n\n    _.each(hookables, function(hookable){\n        clazz.hook(hookable, clazz.prototype[hookable]);\n    });\n    clazz.removePost = removePost;\n};\n\nexports.removeHookPoints = function(clazz, hookables){\n    hookables = hookables || clazz.hookables;\n    _.each(hookables, function(hookable){\n        clazz.removePre(hookable).removePost(hookable); \n    });    \n};\n\n\nfunction removePost(name, fnToRemove) {\n    var proto = this.prototype || this\n      , posts = proto._posts || (proto._posts || {});\n    if (!posts[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      posts[name].length = 0;\n    } else {\n      posts[name] = posts[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n};\n\n\n\n\n\n\n\n/**@todo move to schema util */\n\n\nexports.parseDeclaredArguments = function(funcBody){\n    if(typeof funcBody === 'function') funcBody = funcBody.toString();\n    if(funcBody && typeof funcBody === \"string\"  && funcBody.substr(0,8) == \"function\") {\n        var startArgs = funcBody.indexOf('(') + 1;\n        var endArgs = funcBody.indexOf(')');\n        return  funcBody.substring(startArgs, endArgs)\n    }\n    return \"\";\n}\nvar FunctionNamePattern = /^function\\s+(remote|local|portable)/i;\nexports.typeOf = function(funcBody){\n    funcBody = typeof(funcBody) == 'function' ? funcBody.toString() : funcBody;\n    if(funcBody.indexOf(\"function\")!=0) return \"unknown\";\n    var matcher = FunctionNamePattern.exec(funcBody);\n    return matcher? matcher[1]: 'remote'; //default is remote\n}\n\nexports.methodType = exports.typeOf;\n\nexports.stringifySchema = function(schemaObj ){\n    //logger.trace(\"stringifySchema\", moduleName);\n    var funcs = {};\n    function funcStringifier(key, value) {\n        if (typeof value !== 'function') return value;\n        var body =  value.toString();\n        var funcType = exports.typeOf(body);\n        if(!funcType) return; //'not-available';\n        if(funcType.indexOf(\"local\")>=0) return 'This method can be invoked from server side only';\n        \n        if(funcType.indexOf(\"portable\")>=0){\n            /** the function can be executed client side */\n           return body;\n        }\n        else{\n            /** stub the function */\n            return '$PROXIED$'; //constructProxyFunc(key,args, funcType);\n        }\n    }\n    return JSON.stringify( schemaObj,  funcStringifier, \"\\t\"  );\n}\n\nfunction getReference(pathSchema){\n    var opts = pathSchema.options;\n    \n    /** Mongoose, array of ObjectIDs */\n    if( Array.isArray(opts.type) && opts.type.length>0  &&  opts.type[0] && opts.type[0].ref ) \n        return opts.type[0].ref;\n    /** Single ObjectID Reference*/\n    if(pathSchema.instance == 'ObjectID' && opts.ref) return opts.ref;\n    \n    \n    if(pathSchema.options.ref && pathSchema.instance == 'CustomRef'){\n        /** deform custom ref*/\n       return pathSchema.options.ref;    \n    }\n    /** deform rich reference, array */\n    if(Array.isArray(opts.type ) && pathSchema.caster && \n            pathSchema.caster.instance == 'CustomRef' && pathSchema.caster.options.ref ){ \n        return pathSchema.caster.options.ref;\n    }\n        \n    return null;\n}\n\n/**\n * Merge data recursively from src to dst, return dst\n * @param {Object} dst\n * @param {Object} src\n */\nexports.merge = function(dst, src){\n    dst = dst || {};\n    src = src || {};\n    var traverse = require(\"traverse\");\n    var source = traverse(src);\n    var destination = traverse(dst);\n    source.paths().forEach(function(path){\n        var val = source.get(path);\n        if(typeof(val) != 'object')\n            destination.set(path, val);\n    });\n    return dst;\n}\n\n// Default implementation of exporting a module's methods to client\nexports.exportModuleMethods = function(moduleName, mod){\n    var ret = {};\n    var schemaObj =  mod.schema || (mod.getSchema && mod.getSchema());\n    if(!schemaObj)\n        return null;  \n    ret.moduleName = moduleName;\n    ret.methods = _.clone( schemaObj.methods ) || {};\n    ret.statics = _.clone( schemaObj.statics) || {};\n    return ret;\n};\n\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Context.js":"// ### API References\n\nvar Principal = require(\"./Principal\");\nvar seqnum = 100;\nfunction Context(properties){\n    this.seqnum =  properties.seqnum || (++seqnum);\n    var props = properties;\n    \n    this.request = props.request;\n    this.response = props.response;\n    \n    \n    // ** getRequest() ** \n    //\n    // Returns the express request object\n    this.getRequest = function(){\n        return props.request;\n    }\n    \n    // ** getResponse **\n    //\n    // Returns the express response object\n    this.getResponse = function(){\n        return props.response;\n    }\n    \n    // ** getInvocation **\n    //\n    // Returns the invocation object associated with current context\n    this.getInvocation = function(){\n        return this.invocation;\n    }\n    \n    this.setUser = function(user){\n        this.user = user;\n    }\n    this.getUser = function(){\n        return this.user;\n    }\n    \n    this.setPrincipal = function(principal){\n        props.principal = principal;\n    }\n    // not used yet\n    this.getPrincipal = function(){\n        if(props.principal) return props.principal;\n        return new Principal();\n    }\n    \n    this.toString = function(){\n        return \"[Context@\"+ this.seqnum+\"]\"\n    }\n}\n\nmodule.exports = Context;","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Principal.js":"var logger = require(\"log4js\").getLogger(\"angoose\");\n\n//  This is currently not used as of 0.2.14\n//\n// This class encapsulates authenticated user information. \n// To obtain an instance of this object, you may use `getContext` method\n// defined on the Model/Service class or instance:\n//\n//     MySchema.methods.updateStatus = function(){\n//          var user = this.getContext().getPrincipal();\n//          console.log(\"User is \", user.getUsername());     \n//     }\n//\n// \n\n// ### API References\n\n\nvar  Principal = function(userId, roles){\n    var user = {\n        userId: userId,\n        //username: username,\n        roles: Array.isArray(roles)?roles: (roles?[roles]:undefined)\n    }\n    // ** getUsername() **\n    // \n    // get current logged in user's name/login\n    //this.getUsername = function(){ return user.username};\n\n    // ** getRoles **\n    //\n    // get current logged in user's roles, always returns an array\n    this.getRoles = function(){ return user.roles || [] };\n    \n    // ** getUserId **\n    //\n    // get current logged in user's ID\n    this.getUserId = function(){ return user.userId};\n};\n\nmodule.exports = Principal;","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Exception.js":"var util = require(\"util\");\n\nfunction Exception(err, name){\n    if(err instanceof Error){\n        this.message = err.message;\n        this.name = name || err.name;\n        require('traverse')(err).forEach(function(){\n            if(this.circular) this.remove();\n        })\n        this.cause = err;\n        //this.cause = err;\n        //delete this.cause.domain;  \n    } \n    else{\n        this.message = err;\n        this.name =  name || '';    \n    } \n}\nutil.inherits(Exception, Error);\nmodule.exports = Exception;\n\n ","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Bundle.js":"var logger = require(\"log4js\").getLogger(\"angoose\"), path=require(\"path\"), fs=require(\"fs\");\nvar _ =require(\"underscore\");\nvar toolbox = require(\"./util/toolbox\");\nvar traverse  = require(\"traverse\");\n\nfunction Bundle(){}\nBundle.initHooks = initHooks;\n\nvar hooks = {};\nfunction initHooks(){\n    hooks.pre = {};\n    hooks.post = {};\n    ['generateClient','configClient','exportModules','exportModule','createBundle'].forEach(function(name){\n        hooks.pre[name] = [];           \n        hooks.post[name] = [];\n    })\n}\n\n// synchronous hooks\n\nfunction addHook(loc, method, func){\n    var tmp = hooks[loc][method];\n    logger.debug(\"ADdding bundle hook to\", loc, method, tmp );\n    if(!tmp) return false;\n    tmp.push(func);\n    return true;\n}\nBundle.pre = function(method, func){\n    return addHook('pre', method, func)\n}\nBundle.post = function(method, func){\n    return addHook('post', method, func)\n}\n\nfunction invokeHook(loc, method, arg1, arg2){\n    //console.log(\"***** Bundle.invokeHook ******* \", loc, method)\n    var funcs = hooks[loc][method] || []\n    funcs.forEach(function(func){\n        logger.trace(\"calling hook\", loc, method, func.name);\n        func.call(null, arg1, arg2);\n    });\n}\n\n\n\nfunction angoose(){\n    return require(\"./angoose\");\n}\n//AngooseSchema.prototype =   {\n    //stringify: stringify,\n    //parseDeclaredArguments:toolbox.parseDeclaredArguments,\n    //getReference:getReference,\n    //getFunctionName: getFunctionName\n//};\nvar proto = Bundle.prototype;  \n/**\n * prepare the schema for the module\n * \n * @param {String} moduleName\n * @param {Object} module\n */\nproto.exportModule = function(client, moduleName){\n    invokeHook('pre', 'exportModule', client, moduleName);\n    \n    logger.trace(\"in exportModule\", moduleName);\n    if(client.schemas[moduleName]) return; // already handled\n    var mod = angoose().module(moduleName);\n    var schema = toolbox.exportModuleMethods(moduleName, mod);\n    if(!schema) logger.error(\"Module\", moduleName, \" has no schema, export failed\", mod);\n    else client.schemas[moduleName] = schema;\n    \n    invokeHook('post', 'exportModule', client, moduleName);\n};\n\nproto.exportModules = function(client){\n    invokeHook('pre', 'exportModules', client);\n    \n    logger.debug(\"Exporting all modules\");\n    client.schemas = client.schemas || {};\n    var me = this;\n   \n    var names = angoose().moduleNames();\n    var total = names && names.length;\n    if(!total) return;\n   \n    names.forEach(function(moduleName){\n        var mod = angoose().getClass(moduleName);\n        if(mod.config && mod.config(\"visibility\") === 'local') return;\n        \n        me.exportModule(client, moduleName); \n       \n    }) ;\n    \n    invokeHook('post', 'exportModules', client);\n};\n\nproto.createBundle = function(client){\n    logger.debug(\"Bundle client files\");\n    \n    if(client.source) return; // already generated source\n    var jsonSchemas = toolbox.stringifySchema( client.schemas );\n    var template = path.resolve(__dirname , \"client/angoose-client.js\");\n    var content = fs.readFileSync(template , 'ascii');\n    content = content.replace(\"/**SCHEMA_PLACEHOLDER*/\",  jsonSchemas);\n    content = content.replace(\"/**CONFIG_PLACEHOLDER*/\", JSON.stringify( client.options ));  \n    \n    /**  include client specific extensions*/\n    var clientModuleFile = path.resolve(__dirname , \"client/angoose-angular.js\");\n    content += fs.readFileSync(clientModuleFile, 'ascii');\n\n    clientModuleFile = path.resolve(__dirname , \"client/angoose-jquery.js\");\n    content += fs.readFileSync(clientModuleFile, 'ascii');\n    \n    clientModuleFile = path.resolve(__dirname , \"client/angoose-node.js\");\n    content += fs.readFileSync(clientModuleFile, 'ascii');\n    \n    client.source = content;\n}\n\n/**\n * This method configures an options object which will be served as Angoose client's initial configurations\n * Must set the `client.options` property after the method finishes\n */\nproto.configClient = function(client){\n    logger.debug(\"Setup client options\");\n    client.options = client.options || {};\n    \n    var angooseOpts = angoose().config();\n    var clientOptionNames = ['url-prefix', 'logging'];\n    \n    _.extend(client.options, angooseOpts.client);\n    client.options.urlPrefix = angooseOpts['url-prefix'];\n    \n    clientOptionNames.forEach(function(key){\n        client.options[key] = angooseOpts[key];\n    });\n    //client.options.logging = angoose().config()['logging'] || 'INFO';\n};\n/**\n */\nproto.generateClient = function(clientData){\n    invokeHook('pre', 'generateClient', clientData);\n    // client side configurations\n    \n    invokeHook('pre', 'configClient', clientData);\n    this.configClient(clientData);\n    invokeHook('post', 'configClient', clientData);\n    \n    invokeHook('pre', 'exportModules', clientData);\n    this.exportModules(clientData);\n    invokeHook('post', 'exportModules', clientData);\n    \n    invokeHook('pre', 'createBundle', clientData);\n    this.createBundle(clientData);\n    invokeHook('post', 'createBundle', clientData);\n    \n    invokeHook('post', 'generateClient', clientData);\n    \n};\n//@tood: ,serializeModules,serializeModule,prepareSchema\n// Bundle.hookables = 'generateClient,configClient,exportModules,exportModule,createBundle'.split(\",\");\n// toolbox.addHookPoints(Bundle);\n\nBundle.typeOf = toolbox.typeOf;\nmodule.exports = Bundle;","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Remotable.js":"// This is the base class for Angoose model classes and service classes. \n// This is used internally and it's here only for listing the APIs common\n// to all Model and Service classes.  \n\nvar logger = require(\"log4js\").getLogger(\"angoose\");\nvar _ = require(\"underscore\");\nvar Class = require(\"./util/classy\");\n\nvar toolbox = require(\"./util/toolbox\");\n\n// ### API Rereferences\n// **getContext()**\n//\n// This method allows you obtain the execution context.\n// See [Context](Context.html) for more. \n//  \n// Note this method is also available on the class(function) as well. i.e.,\n//\n//      /** MyModel is subclass of Remotable */\n//      var instance = new MyModel(); \n//      /** Following yields true */\n//      MyModel.getContext() === instance.getContext(); \n//\nvar getContext = function(){\n    return require(\"./angoose\").getContext()\n}\n\nvar  Remotable = Class.$extend({});\nRemotable.prototype = {\n    getContext: getContext\n}\n\nRemotable._angoosemeta ={ baseClass: 'Remotable' }\nRemotable.extend = extend;\nRemotable.getContext = getContext;\n// ** extend **\n//\n// This static method is used to create Angoose model or service classes.\n// All classes created using this method is a subclass of `Remotable`\nfunction extend(target, options){\n    options = options||{};\n    var parentClass = this;\n    logger.trace(\"Extending from \",   parentClass._angoosemeta.name, options);\n    var rv = null;\n    if(typeof (target) == 'function'){\n        rv = target;\n        mixinInstance(parentClass, rv, options);\n        \n        /**@todo: temp hack */\n        bindMongooseMethods(rv);       \n    }\n    else{ \n        /** schema object */ \n        rv = parentClass.$extend( target );\n    }\n   \n    /** mixin Angoose class level functions */       \n    rv = mixinStatic(parentClass, rv, options);   \n    if(rv._angoosemeta.name){\n        /**  register it with Angoose */\n       //require(\"./angoose\").registerClass(rv._angoosemeta.name, rv);\n    }\n    return rv;\n}\nfunction mixinInstance(parentClass, subClass, options){\n    subClass.prototype.getContext = getContext;\n    \n    /** look for static classes*/\n   \n}\nfunction mixinStatic(parentClass, subClass, options){\n    /** mixin Angoose functions to the new class */\n   /** if(subClass.extend || subClass.getContext ) throw \"Class already has 'extend' or 'getContext' property/method\" */\n   \n    /** mixing static properties from parentClass to subClass */\n    for(var prop in parentClass){\n        var val = parentClass[prop];\n        if(!parentClass.hasOwnProperty(prop) || typeof(val) != 'function') continue;\n        if(isRemotableReserved(prop)) continue;\n        if(subClass[prop]) {\n            logger.warn(\"Cannot mixin subclass: property '\"+ prop+\"' already exists on subclass\");\n            throw \"Subclass already has property '\"+ prop+\"' defined.\";\n        }\n        //logger.trace(\"Mixing: \", prop)\n        subClass[prop] = val;\n    }   \n    // subClass.extend = extend;\n    // subClass.getContext = getContext;\n    subClass._angoosemeta = _.extend({}, parentClass._angoosemeta);\n    subClass._angoosemeta = _.extend(subClass._angoosemeta, options)\n   \n    return subClass;\n}\n\n\nfunction isRemotableReserved(methodName){\n    /** check if method is reserved by the Remotable interface */\n  return methodName.indexOf(\"_\") == 0 || methodName.indexOf(\"$\") == 0 || ['constructor',   'isRemotableReserved'].indexOf(methodName)>=0;   \n}\n/** a$ is Angoose's internal property*/\n//Remotable.prototype._angoosemeta = {};\n\nRemotable.getContext = getContext;\nRemotable.isRemotableReserved=isRemotableReserved;\n\nmodule.exports = Remotable\n\n\nRemotable.mixin = function(opts, target){\n    opts = opts || {};\n    target.getSchema = getSchema;\n    target._angoosemeta  = toolbox.merge(target._angoosemeta , opts);\n    target._angoosemeta.baseClass = target._angoosemeta.baseClass || 'Service';\n    target.getContext = getContext; //deprecated\n    target.config = config;\n    if(target._angoosemeta.baseClass == 'Model')\n        bindMongooseMethods(target);\n}\n\nfunction config(path, opts){\n    var conf = this._angoosemeta;\n    switch(arguments.length){\n        case 0: return conf;\n        case 1: return toolbox.getter(conf, path);\n        case 2: toolbox.setter(conf, path, opts);\n    }\n    return this;        \n}\nfunction getSchema(){\n    var thisClass = this;\n    var schema = {statics: {}, methods:{} };\n    for(var name in thisClass){\n        var val = thisClass[name];\n        if( filter(name) ) continue;\n        if(typeof (val) != 'function') continue;\n        schema.statics[name] = val;\n    }\n    if(typeof(thisClass) == 'function'){\n        schema.methods = _.extend({}, thisClass.prototype)\n    }\n    return schema;\n}\n\n\nfunction filter(methodName){\n     if(Remotable.isRemotableReserved(methodName)) return true;\n     if(['extend', 'getContext', 'getSchema','mixin','toJSON' ].indexOf(methodName)>=0) return true;\n     return false;\n}\n\nfunction bindMongooseMethods(modelClass){\n    var staticMethods = \"populate,find,findOne,findById,findByIdAndRemove,findByIdAndUpdate,findOneAndRemove,findOneAndUpdate,update,remove,count,geoNear,geoSearch,aggregate\".split(\",\");\n    _.each(staticMethods, function(method){ \n        var fn = modelClass[method];\n        if( typeof(fn) == 'function'){\n            modelClass[method] =  toolbox.bindCallback(modelClass, fn )\n        }\n    });\n    var instanceMethods = \"save,remove,populate,update\".split(\",\");\n    _.each(instanceMethods, function(method){ \n        var fn = modelClass.prototype[method];\n        if( typeof(fn) == 'function'){\n            modelClass.prototype[method] =  toolbox.bindCallback(null, fn )\n        }\n    }); \n}\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/util/classy.js":"/**\n * Classy - classy classes for JavaScript.  Docs: http://classy.pocoo.org/\n *\n * :copyright: (c) 2011 by Armin Ronacher. \n * :license: BSD.\n */\n!function (definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)\n  else this.Class = definition()\n}(function (undefined) {\n  var\n    CLASSY_VERSION = '1.4',\n    context = this,\n    old = context.Class,\n    disable_constructor = false;\n\n  /* we check if $super is in use by a class if we can.  But first we have to\n     check if the JavaScript interpreter supports that.  This also matches\n     to false positives later, but that does not do any harm besides slightly\n     slowing calls down. */\n  var probe_super = (function(){$super();}).toString().indexOf('$super') > 0;\n  function usesSuper(obj) {\n    return !probe_super || /\\B\\$super\\b/.test(obj.toString());\n  }\n\n  /* helper function to set the attribute of something to a value or\n     removes it if the value is undefined. */\n  function setOrUnset(obj, key, value) {\n    if (value === undefined)\n      delete obj[key];\n    else\n      obj[key] = value;\n  }\n\n  /* gets the own property of an object */\n  function getOwnProperty(obj, name) {\n    return Object.prototype.hasOwnProperty.call(obj, name)\n      ? obj[name] : undefined;\n  }\n\n  /* instanciate a class without calling the constructor */\n  function cheapNew(cls) {\n    disable_constructor = true;\n    var rv = new cls;\n    disable_constructor = false;\n    return rv;\n  }\n\n  /* the base class we export */\n  var Class = function() {};\n\n  /* restore the global Class name and pass it to a function.  This allows\n     different versions of the classy library to be used side by side and\n     in combination with other libraries. */\n  Class.$noConflict = function() {\n    try {\n      setOrUnset(context, 'Class', old);\n    }\n    catch (e) {\n      // fix for IE that does not support delete on window\n      context.Class = old;\n    }\n    return Class;\n  };\n\n  /* what version of classy are we using? */\n  Class.$classyVersion = CLASSY_VERSION;\n\n  /* extend functionality */\n  Class.$extend = function(properties) {\n    var super_prototype = this.prototype;\n\n    /* disable constructors and instanciate prototype.  Because the\n       prototype can't raise an exception when created, we are safe\n       without a try/finally here. */\n    var prototype = cheapNew(this);\n\n    /* copy all properties of the includes over if there are any */\n    if (properties.__include__)\n      for (var i = 0, n = properties.__include__.length; i != n; ++i) {\n        var mixin = properties.__include__[i];\n        for (var name in mixin) {\n          var value = getOwnProperty(mixin, name);\n          if (value !== undefined)\n            prototype[name] = mixin[name];\n        }\n      }\n \n    /* copy class vars from the superclass */\n    properties.__classvars__ = properties.__classvars__ || {};\n    if (prototype.__classvars__)\n      for (var key in prototype.__classvars__)\n        if (!properties.__classvars__[key]) {\n          var value = getOwnProperty(prototype.__classvars__, key);\n          properties.__classvars__[key] = value;\n        }\n\n    /* copy all properties over to the new prototype */\n    for (var name in properties) {\n      var value = getOwnProperty(properties, name);\n      if (name === '__include__' ||\n          value === undefined)\n        continue;\n\n      prototype[name] = typeof value === 'function' && usesSuper(value) ?\n        (function(meth, name) {\n          return function() {\n            var old_super = getOwnProperty(this, '$super');\n            this.$super = super_prototype[name];\n            try {\n              return meth.apply(this, arguments);\n            }\n            finally {\n              setOrUnset(this, '$super', old_super);\n            }\n          };\n        })(value, name) : value\n    }\n\n    /* dummy constructor */\n    var rv = function() {\n      if (disable_constructor)\n        return;\n      var proper_this = context === this ? cheapNew(arguments.callee) : this;\n      if (proper_this.__init__)\n        proper_this.__init__.apply(proper_this, arguments);\n      proper_this.$class = rv;\n      return proper_this;\n    }\n\n    /* copy all class vars over of any */\n    for (var key in properties.__classvars__) {\n      var value = getOwnProperty(properties.__classvars__, key);\n      if (value !== undefined)\n        rv[key] = value;\n    }\n\n    /* copy prototype and constructor over, reattach $extend and\n       return the class */\n    rv.prototype = prototype;\n    rv.constructor = rv;\n    rv.$extend = Class.$extend;\n    rv.$withData = Class.$withData;\n    return rv;\n  };\n\n  /* instanciate with data functionality */\n  Class.$withData = function(data) {\n    var rv = cheapNew(this);\n    for (var key in data) {\n      var value = getOwnProperty(data, key);\n      if (value !== undefined)\n        rv[key] = value;\n    }\n    return rv;\n  };\n\n  /* export the class */\n  return Class;\n});","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Model.js":"var logger = require(\"log4js\").getLogger(\"angoose\");\nvar _ =require(\"underscore\");\nvar Remotable = require(\"./Remotable\")\n\n// ## angoose.MODEL\n// Model is one of two main artifacts in Angoose. Model classes define the data schema \n// as well as CRUD operations and other related functions. \n//\n// Angoose Model is built on top of Mongoose model and adds a few capabilities to allow\n// the remote invocation. To create a Model class, simply define a regular Mongoose model schema\n// and export the Mongoose model class like below:  \n//  \n//\n//      var mongoose = require('mongoose');\n//      var SampleSchema = mongoose.Schema({\n//          email:  {type: String, required: true},\n//          firstname: {type: String, required:true },\n//          lastname: {type: String, required:true },\n//      })\n//      module.exports = mongoose.model('SampleUser', SampleSchema);\n//\n//\n// Requirements for creating models:\n// - Model/schema file must be located under one of the `modelDir` directories.\n// - Each file defines one model\n// - `module.exports` must be set to the return value of `mongoose.model('name', schema)` call.\n\nvar Model = Remotable.extend({}, {baseClass: 'Model'});\n\nModel.getSchema = function(){\n    return this.schema;\n}\n\n// ### API References\n//\n\n \nmodule.exports = Model;\n// \n// function getData(doc, path){\n    // if(!path || !doc) return undefined;\n     // var   pieces = path.split('.');\n      // var obj = doc;\n      // for (var i = 0, l = pieces.length; i < l; i++) {\n        // obj = undefined === obj || null === obj\n          // ? undefined\n          // : obj[pieces[i]];\n      // }\n      // return obj;\n// }\n// \n// function setData(doc, path, val){\n    // if(!path || !doc ) return;\n     // var   pieces = path.split('.');\n      // var obj = doc;\n      // for (var i = 0, len = pieces.length; i < len; i++) {\n          // if(i+1  == len ) // last one\n          // {\n              // obj[ pieces[i]] = val;\n              // return;\n          // }\n          // obj[pieces[i]] = obj[pieces[i]] || {};\n          // obj = obj[pieces[i]] || {};\n      // }\n// }","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/lib/Service.js":"var logger = require(\"log4js\").getLogger(\"angoose\");\nvar _ =require(\"underscore\");\nvar Remotable = require(\"./Remotable\")\n\n// ## angoose.Service\n// Service is one of two main artifacts in Angoose. Service classes are used to define business operations that \n// are not necessarily tied to database models.\n// \n// To create an angoose Service, you just need to extend from this class:\n//\n//      var angoose = require(\"angoose\");\n//      var service = {\n//          geoEncode: function(stringAddress){\n//                  /** call google API */\n//                  return coordinates\n//          }    \n//      }\n//      module.export = angoose.service('GeoService', service);\n//\n// The Service class file must be located under one of the `modelDir` or `serviceDir` directories.\n//\nvar serviceProto = {\n    toJSON: function(){\n        return {};\n    }\n}\nvar Service = Remotable.extend(serviceProto,{baseClass:'Service'});\n\nService.getSchema = function(){\n    var thisClass = this;\n    var schema = {statics: {} };\n    \n    schema.methods = _.extend({}, thisClass.prototype)\n    \n    for(var name in thisClass.prototype){\n        if( filter(name) ) continue;\n        if(!thisClass.prototype.hasOwnProperty(name)) continue;\n        var val = thisClass.prototype[name];\n        if(typeof(val)!='function') continue;\n        schema.methods[name] = val;   \n    }\n    \n    for(var name in thisClass){\n        if(!thisClass.hasOwnProperty(name)) continue;\n        var val = thisClass[name];\n        if( filter(name) ) continue;\n        if(typeof (val) != 'function') continue;\n        schema.statics[name] = val;\n    }\n    return schema;\n}\n\nfunction filter(methodName){\n     if(Remotable.isRemotableReserved(methodName)) return true;\n     if(['extend', 'getContext', 'getSchema','toJSON' ].indexOf(methodName)>=0) return true;\n     return false;\n}\nmodule.exports = Service;","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/Gruntfile.js":"\nmodule.exports = function(grunt) {\n    // Project configuration.\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    karma: {\n        options: {\n            basePath: './',\n            frameworks: ['jasmine'],\n            autoWatch: true,\n            browsers: ['PhantomJS'],\n            junitReporter: {\n              outputFile: 'build/karma-unit.xml',\n              suite: 'unit'\n            }, \n            singleRun:false,\n            preprocessors:{\n              //'**/*.tpl':['html2js'],\n              //'**/*.tpl.html':['html2js']\n            },\n            //runnerPort:9999,\n            reporters: 'dots',\n            client: {\n              mocha: {\n                ui: 'bdd'\n              }\n            }\n        },\n        e2e: {\n            background:false,\n            frameworks: ['ng-scenario'],\n            autoWatch: false,\n            browsers: ['Chrome'],\n            singleRun: true,\n            proxies: {\n              '/': 'http://localhost:8000/'\n            },\n            urlRoot: '/__karma/',\n            logLevel: 'trace',\n            junitReporter: {\n              outputFile: 'build/karma/unit.xml',\n              suite: 'e2e'\n            }\n        },\n        unit: {\n        }\n    },\n    watch: {\n        testall:{\n            files: [\"lib/**/*.js\", \"test/**/*.js\"],\n            tasks:['test'],\n            options: { debounceDelay: 250 }    \n        }\n    },\n    jasmine_node: {\n            specNameMatcher: \"spec\", // load only specs containing specNameMatcher\n            projectRoot: \"./test\",\n            requirejs: false,\n            forceExit: true,\n            jUnit: {\n              report: true,\n              savePath : \"./build/reports/\",\n              useDotNotation: true,\n              consolidate: true\n            }\n    },\n     shell:{\n         'test-server': {\n             command: \"./kick\"\n         }\n         \n     }\n  });\n\n    // Load the plugin that provides the \"uglify\" task.\n    grunt.loadNpmTasks('grunt-jasmine-node');\n    grunt.loadNpmTasks('grunt-shell');\n    grunt.loadNpmTasks('grunt-contrib-watch');\n    grunt.loadNpmTasks('grunt-karma');\n\n    grunt.registerTask('combine',['concat', 'import-modules'] );\n  \n    // Default task(s).\n    grunt.registerTask('default', []);\n  \n    grunt.registerTask(\"test\", \"Serverside unit tests\", function(argPattern){\n        // change NODE_ENV to unittest \n        grunt.config.set(\"jasmine_node.projectRoot\", \"./test\");\n        var pattern = grunt.option(\"file\") || argPattern || \"\";\n        grunt.log.writeln(\"running   unit test:\", (pattern||\"\"));\n        pattern && grunt.config.set(\"jasmine_node.match\" ,  \".*\" + pattern + \".*\");\n        grunt.task.run('jasmine_node');\n    });\n    \n    grunt.registerTask(\"ctest\", \"Client side unit test\", function(argPattern){\n      var pattern = grunt.option(\"file\") || argPattern || \"\";\n      grunt.log.writeln(\"running angular unit test:\", (pattern||\"\"));\n      grunt.config.set(\"karma.options.files\", collectKarmaFiles(pattern));\n      \n      // start angoose, this will cause angoose to generate the client file\n      require(\"./test/lib/angular-test-server\");\n      \n      grunt.task.run(\"karma:unit\");\n  });\n    \n    grunt.registerTask(\"server\", \"Run test server on port 9988\", function(argPattern){\n        // change NODE_ENV to unittest \n        grunt.log.writeln(\"Starting test server\");\n        require(\"./test/server\").startServer();\n    });\n  \n    grunt.registerTask('autotest', 'watch and test', function(argPattern) {\n\n        var watched= [\"lib/**/*.js\", \"test/**/*.js\", \"models/**/*.js\", \"extensions/**/*.js\"];\n       // set the correct list of file to watch according to the argument passed\n        grunt.config('watch.autotest.files', watched);\n        grunt.config('watch.autotest.tasks',  (argPattern? 'test:'+ argPattern: 'test'));\n        grunt.task.run(argPattern? 'test:'+ argPattern: 'test');\n        grunt.task.run('watch:autotest');\n        \n    })\n};\n\nprocess.on('uncaughtException',function(e) {\n    console.log(\" Unhandled Error in Grunt -----> : \", e,   e.stack);\n});\n\n\nfunction collectKarmaFiles(grepPattern){\n        // collect the karma test files\n    var root = process.cwd();\n        \n        var files = [   \"./test/lib/angular/angular.js\", \n                        \"./test/lib/angular/angular-resource.js\", \n                        \"./test/lib/angular/angular-sanitize.js\", \n                        \"./test/lib/angular/angular-route.js\",\n                        \"./test/lib/angular/angular-mocks.js\",\n                        \"./build/generated-client.js\"\n                    ];\n        // \"/lib/angular-file-upload.js\", \n        //\"/lib/angular/ui/angular-ui.js\", \n        //\"/lib/bootstrap/ui-bootstrap-tpls-0.6.0.js\", \n        //\"/lib/select2/select2.js\", \n        //\"/lib/select2/select2-angular.js\", \n        //\"/lib/bootstrap/bootstrap-datepicker-inline.js\", \n        //\"/lib/bootstrap/bootstrap-timepicker-inline.js\", \n    \n      if(grepPattern)\n        files.push( \"./test/ui/**/*\"+ grepPattern+\"*.js\");\n      else\n        files.push(\"./test/ui/**/*.js\");\n      console.log(\"Karma files\", files);\n      return files;    \n}","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/angoose-client-generated.js":"/** Angoose Client Core */\r\n/**  depdnencies: http, Q */\nvar AngooseClient = function() {};\nfunction BootstrapAngoose(){\n       if(typeof(console) == 'undefined'){\n            console = { log: function(){} }\n       }\n       console.log(\"Bootstraping angoose-client\");\n    \n    // ** getClass **\n    //\n    // Get the model class, you may call static method such as findXXX or create new model instance\n    //      \n    //      var SampleUser = angoose.getClass('SampleUser');\n    //      SampleUser.findOne();\n    //      var u = new SampleUser(); \n    //\n    \n    var counterBase = Math.round(Math.random() * 10000) * 10000;\n    var nextCounter = function() {\n        return counterBase++;\n    }\n    var encode$ = function(obj){\n        if(!obj || typeof obj != 'object') return obj;\n        if(obj && obj.length){\n            for(var i=0;i<obj.length;i++){\n                obj[i] = encode$(obj[i]);\n            };\n        }\n        else{\n            //console.log(\"Type\", (typeof obj), obj)\r\n            for(var key in obj){\r\n                var val = encode$(obj[key]);\r\n                if(key.indexOf('$')==0){\r\n                    delete obj[key];\r\n                    key = \"_mongo_\"+key;\r\n                }\r\n                obj[key] = val;\r\n            }            \n        }\n        return obj;\n    }\n    var getter = function (path) {\n      var   pieces = path.split('.');\n      var obj = this;\n      for (var i = 0, l = pieces.length; i < l; i++) {\n        obj = undefined === obj || null === obj\n          ? undefined\n          : obj[pieces[i]];\n      }\n      return obj;\n    };\n\n\n    var handleReturn = function(retval, callback, deferred, error){\n        if(callback) return callback(error, retval);\n        return  error? deferred.reject(error) : deferred.resolve(retval);\n    }\n\n    function staticInvoker(modelClass, methodName, methodArgs) {\n        return invoker( modelClass,  methodName, methodArgs, null);\n\n    };\n    function instanceInvoker(modelClass, model, methodName, methodArgs) {\n        //var modelClass = getClass(model.classname$)\n        return invoker( modelClass, methodName, methodArgs, model);\n    }\n    function invoker(modelClass, methodName, methodArgs, modelInstance) {\n        // modelInstance can be null, everything else is required.\n        var modelName =  modelClass.modelName;\n         console.log(\"invoker: \", modelName, methodName, methodArgs, modelClass);\n        var callback = null;\n        var isStatic = modelInstance==null;\n        var depends = modelClass.dependencies$;\n        var data = {\n            method : methodName,\n            seqnumber : nextCounter(),\n            args : [],\n            clazz: modelName,\n            static: isStatic\n        }\n        for (var i = 0; methodArgs && methodArgs.length > i; i++) {\n            if(typeof methodArgs[i] != 'function')\n                data.args.push(methodArgs[i]);\n            else{\n                callback = methodArgs[i]\n                data.args.push(\"$callback\")\n                console.log(\"Callback provided\");\n            }\n        }\n        if(!isStatic) {\n            data.instance = modelInstance;  // including model instance data for instance methods\n        } \n\n        // angular http ignores all key names starting with $, this will break the mongo query\n        data = encode$(data);\n         console.log(\"****** BEGIN Client Call #\", data.seqnumber,modelName, methodName, data);\n        var http = depends['http'];\n        var theQ = depends['promise'];\n        if (!http || !theQ) throw \"Missing http and/or Q dependencies\";\n        var deferred = theQ.defer();\n        var ret = http.post((getConfigs().urlPrefix || '/angoose') + \"/rmi/\" + modelName + \"/\" + methodName, data);\n        ret.done(function(retdata) {\n             console.log(\"****** END Client Call #\", data.seqnumber, \" result:\", retdata);\n            var val = undefined;\n            //@todo construct object, ret value types:  1) model data, 2) list of model data, 3) String, 4) object\n            if (retdata && retdata.retval  && ( retdata.datatype =='model' || retdata.datatype =='models')) {\n                \n                if(retdata.datatype == 'model'){\n                    val = new modelClass(retdata.retval);\n                }\n                else{\n                    var models = [];\n                    for(var i =0; i< retdata.retval.length; i++){\n                        models.push( new modelClass( retdata.retval[i]));\n                    }\n                    val = models;    \n                }    \n                //return handleReturn(val, callback, deferred);\n                //                \n                //return deferred.resolve(models);\n            }\n            if (retdata && retdata.instance && !isStatic) {\n                // state has been changed on the server side\n                modelInstance.mergeData(retdata.instance);\n                 console.log(\"Merged server side data\");\n            }\n            if(retdata.success)\n                return handleReturn(val || retdata.retval, callback, deferred);\n            var ex = retdata.exception? (retdata.exception.message || retdata.exception.value)  : retdata;\n            return handleReturn(null, callback, deferred, ex);\n            //deferred.reject(ex)\n        }, function(errdata) {\n             console.log(\"****** END Client Call #\", data.seqnumber, \" error:\", errdata);\n            if(!errdata) return handleReturn(null, callback, deferred, \"Unexpected server error occurred, please contact admin\");\n            var ex = errdata.exception?  (errdata.exception.message || errdata.exception.value) : errdata;\n            return handleReturn(null, callback, deferred, ex);\n            //return deferred.reject(ex);\n        })\n        if(!callback) return deferred.promise;\n    }\r\n    \r\n    function createProxy(module, funcName, func, funcType){\r\n        if(typeof(func) == 'function') return func;\r\n        if(typeof(func) == \"string\" && func.indexOf(\"function\") == 0){\r\n            var vname;\r\n            return eval(\"vname=\"+func);\r\n        }\r\n        if(funcType == 'static'){\r\n            return function proxy(){\r\n                return staticInvoker(module, funcName, arguments);   \r\n            }    \r\n        };\r\n        if(funcType == 'instance'){\r\n            return function proxy(){\r\n                return instanceInvoker(module, this, funcName, arguments);   \r\n            }    \r\n        };\r\n        \r\n    }\n    /** compile the model based on the server side schema */\n    function compile(modelName, schema, dependencies) {\n         console.log(\"Client: compiling schema \" , modelName)\n        var model = function AngooseModule(data) {\n            //@todo proper clone\n            for (var i in data) {\n                this[i] = data[i];\n            }\n        };\n        \n        // static methods\n        for(var name in schema.statics){\r\n            model[name] = createProxy(model, name,  schema.statics[name], 'static');\r\n        }\r\n        for(var name in schema.methods){\r\n            model.prototype[name] = createProxy(model, name,  schema.methods[name], 'instance');\r\n        }\n        \n        //model.angoose$ = staticInvoker;\n        model.dependencies$ = dependencies;\n        model.schema = schema;\n        //model.prototype.angoose$ = instanceInvoker;\n        //model.prototype.classname$ = modelName;\n        //model.prototype.schema$ = schema;\n        model.prototype.get = getter;\n        model.modelName = modelName; // this is to be compatible with backend mongoose\r\n        model.name = modelName; \n\n        // merge data into this instance\n        model.prototype.mergeData = function(source) {\n            if ( typeof source != \"object\")\n                throw \"Invalid source object, must be an model instance\";\n            //@todo: proper implementation\n            for (var i in source) {\n                this[i] = source[i];\n            }\n        }\n        AngooseClient.models = AngooseClient.models || {};\n        AngooseClient.models[modelName] = model;\n        return model;\n    };\n\n    function modelNames() {\n        var ret = [];\n        for (var key in getSchemas()) {\n            ret.push(key);\n        }\n        return ret;\n    };\n\n    function init(dependencies) {\n        if (AngooseClient.initialized) {\n             console.log(\"init has been called\");\n            return;\n        }\n        AngooseClient.dependencies = dependencies;\n         console.log(\"Initializing client angoose models\")\n        for (var mName in getSchemas()) {\n            compile(mName, getSchemas()[mName], dependencies);\n        }\n        AngooseClient.initialized = true;\n    };\n    function getClass(name) {\n        if (!AngooseClient.initialized)\n            throw \"Angoose models not initialized yet\";\n        return AngooseClient.models[name];\n    };\n    function getConfigs() {  return  {\"urlPrefix\":\"/angoose\"} };\n    function getSchemas() {  return  {\n\t\"SampleService\": {\n\t\t\"moduleName\": \"SampleService\",\n\t\t\"methods\": {},\n\t\t\"statics\": {\n\t\t\t\"listFavoriteDestinations\": \"$PROXIED$\",\n\t\t\t\"testExecutionContext\": \"$PROXIED$\",\n\t\t\t\"testPromiseReturn\": \"$PROXIED$\",\n\t\t\t\"testErrorBack\": \"$PROXIED$\",\n\t\t\t\"config\": \"$PROXIED$\"\n\t\t}\n\t},\n\t\"SampleUser\": {\n\t\t\"moduleName\": \"SampleUser\",\n\t\t\"methods\": {\n\t\t\t\"getFullname\": \"function portable(){\\n    //_instance_portable\\n    console.log(\\\"getFullname\\\", this);\\n    return  (this.firstname ? this.firstname +\\\" \\\": \\\"\\\") + (this.lastname || \\\"\\\");\\n}\",\n\t\t\t\"setPassword\": \"$PROXIED$\",\n\t\t\t\"save\": \"$PROXIED$\",\n\t\t\t\"remove\": \"$PROXIED$\",\n\t\t\t\"populate\": \"$PROXIED$\"\n\t\t},\n\t\t\"statics\": {\n\t\t\t\"getSample\": \"$PROXIED$\",\n\t\t\t\"checkExists\": \"$PROXIED$\",\n\t\t\t\"populate\": \"$PROXIED$\",\n\t\t\t\"find\": \"$PROXIED$\",\n\t\t\t\"findOne\": \"$PROXIED$\",\n\t\t\t\"findById\": \"$PROXIED$\",\n\t\t\t\"findByIdAndRemove\": \"$PROXIED$\",\n\t\t\t\"findByIdAndUpdate\": \"$PROXIED$\",\n\t\t\t\"findOneAndRemove\": \"$PROXIED$\",\n\t\t\t\"findOneAndUpdate\": \"$PROXIED$\",\n\t\t\t\"update\": \"$PROXIED$\",\n\t\t\t\"remove\": \"$PROXIED$\",\n\t\t\t\"count\": \"$PROXIED$\",\n\t\t\t\"geoNear\": \"$PROXIED$\",\n\t\t\t\"geoSearch\": \"$PROXIED$\",\n\t\t\t\"create\": \"$PROXIED$\"\n\t\t},\n\t\t\"paths\": {\n\t\t\t\"email\": {\n\t\t\t\t\"enumValues\": [],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"email\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"match\": {},\n\t\t\t\t\t\"unique\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": {\n\t\t\t\t\t\"unique\": true,\n\t\t\t\t\t\"background\": true\n\t\t\t\t},\n\t\t\t\t\"isRequired\": true\n\t\t\t},\n\t\t\t\"firstname\": {\n\t\t\t\t\"enumValues\": [],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"firstname\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\",\n\t\t\t\t\t\"required\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": null,\n\t\t\t\t\"isRequired\": true\n\t\t\t},\n\t\t\t\"lastname\": {\n\t\t\t\t\"enumValues\": [],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"lastname\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\",\n\t\t\t\t\t\"required\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": null,\n\t\t\t\t\"isRequired\": true\n\t\t\t},\n\t\t\t\"status\": {\n\t\t\t\t\"enumValues\": [\n\t\t\t\t\t\"inactive\",\n\t\t\t\t\t\"active\",\n\t\t\t\t\t\"disabled\",\n\t\t\t\t\t\"archived\"\n\t\t\t\t],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"status\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\",\n\t\t\t\t\t\"enum\": [\n\t\t\t\t\t\t\"inactive\",\n\t\t\t\t\t\t\"active\",\n\t\t\t\t\t\t\"disabled\",\n\t\t\t\t\t\t\"archived\"\n\t\t\t\t\t],\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"def\": \"inactive\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null,\n\t\t\t\t\"isRequired\": true\n\t\t\t},\n\t\t\t\"password\": {\n\t\t\t\t\"enumValues\": [],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"password\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t},\n\t\t\t\"verified\": {\n\t\t\t\t\"path\": \"verified\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"Boolean\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t},\n\t\t\t\"groupRef\": {\n\t\t\t\t\"path\": \"groupRef\",\n\t\t\t\t\"instance\": \"ObjectID\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"ObjectId\",\n\t\t\t\t\t\"ref\": \"SampeUserGroup\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t},\n\t\t\t\"_id\": {\n\t\t\t\t\"path\": \"_id\",\n\t\t\t\t\"instance\": \"ObjectID\",\n\t\t\t\t\"setters\": [\n\t\t\t\t\t\"not-supported\"\n\t\t\t\t],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"ObjectId\",\n\t\t\t\t\t\"auto\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": null,\n\t\t\t\t\"defaultValue\": \"not-supported\"\n\t\t\t},\n\t\t\t\"__v\": {\n\t\t\t\t\"path\": \"__v\",\n\t\t\t\t\"instance\": \"Number\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"Number\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t}\n\t\t},\n\t\t\"options\": {\n\t\t\t\"collection\": \"SampleUsers\",\n\t\t\t\"discriminatorKey\": \"type\",\n\t\t\t\"id\": true,\n\t\t\t\"noVirtualId\": false,\n\t\t\t\"_id\": true,\n\t\t\t\"noId\": false,\n\t\t\t\"read\": null,\n\t\t\t\"shardKey\": null,\n\t\t\t\"autoIndex\": true,\n\t\t\t\"minimize\": true,\n\t\t\t\"versionKey\": \"__v\",\n\t\t\t\"capped\": false,\n\t\t\t\"bufferCommands\": true,\n\t\t\t\"strict\": true,\n\t\t\t\"pluralization\": true\n\t\t}\n\t},\n\t\"SampleUserGroup\": {\n\t\t\"moduleName\": \"SampleUserGroup\",\n\t\t\"methods\": {\n\t\t\t\"save\": \"$PROXIED$\",\n\t\t\t\"remove\": \"$PROXIED$\",\n\t\t\t\"populate\": \"$PROXIED$\"\n\t\t},\n\t\t\"statics\": {\n\t\t\t\"populate\": \"$PROXIED$\",\n\t\t\t\"find\": \"$PROXIED$\",\n\t\t\t\"findOne\": \"$PROXIED$\",\n\t\t\t\"findById\": \"$PROXIED$\",\n\t\t\t\"findByIdAndRemove\": \"$PROXIED$\",\n\t\t\t\"findByIdAndUpdate\": \"$PROXIED$\",\n\t\t\t\"findOneAndRemove\": \"$PROXIED$\",\n\t\t\t\"findOneAndUpdate\": \"$PROXIED$\",\n\t\t\t\"update\": \"$PROXIED$\",\n\t\t\t\"remove\": \"$PROXIED$\",\n\t\t\t\"count\": \"$PROXIED$\",\n\t\t\t\"geoNear\": \"$PROXIED$\",\n\t\t\t\"geoSearch\": \"$PROXIED$\",\n\t\t\t\"create\": \"$PROXIED$\"\n\t\t},\n\t\t\"paths\": {\n\t\t\t\"name\": {\n\t\t\t\t\"enumValues\": [],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"name\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"unique\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": {\n\t\t\t\t\t\"unique\": true,\n\t\t\t\t\t\"background\": true\n\t\t\t\t},\n\t\t\t\t\"isRequired\": true\n\t\t\t},\n\t\t\t\"description\": {\n\t\t\t\t\"enumValues\": [],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"description\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t},\n\t\t\t\"_id\": {\n\t\t\t\t\"path\": \"_id\",\n\t\t\t\t\"instance\": \"ObjectID\",\n\t\t\t\t\"setters\": [\n\t\t\t\t\t\"not-supported\"\n\t\t\t\t],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"ObjectId\",\n\t\t\t\t\t\"auto\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": null,\n\t\t\t\t\"defaultValue\": \"not-supported\"\n\t\t\t},\n\t\t\t\"__v\": {\n\t\t\t\t\"path\": \"__v\",\n\t\t\t\t\"instance\": \"Number\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"Number\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t}\n\t\t},\n\t\t\"options\": {\n\t\t\t\"collection\": \"SampleGroups\",\n\t\t\t\"id\": true,\n\t\t\t\"noVirtualId\": false,\n\t\t\t\"_id\": true,\n\t\t\t\"noId\": false,\n\t\t\t\"read\": null,\n\t\t\t\"shardKey\": null,\n\t\t\t\"autoIndex\": true,\n\t\t\t\"minimize\": true,\n\t\t\t\"discriminatorKey\": \"__t\",\n\t\t\t\"versionKey\": \"__v\",\n\t\t\t\"capped\": false,\n\t\t\t\"bufferCommands\": true,\n\t\t\t\"strict\": true,\n\t\t\t\"pluralization\": true\n\t\t}\n\t},\n\t\"Todo\": {\n\t\t\"moduleName\": \"Todo\",\n\t\t\"methods\": {\n\t\t\t\"save\": \"$PROXIED$\",\n\t\t\t\"remove\": \"$PROXIED$\",\n\t\t\t\"populate\": \"$PROXIED$\"\n\t\t},\n\t\t\"statics\": {\n\t\t\t\"populate\": \"$PROXIED$\",\n\t\t\t\"find\": \"$PROXIED$\",\n\t\t\t\"findOne\": \"$PROXIED$\",\n\t\t\t\"findById\": \"$PROXIED$\",\n\t\t\t\"findByIdAndRemove\": \"$PROXIED$\",\n\t\t\t\"findByIdAndUpdate\": \"$PROXIED$\",\n\t\t\t\"findOneAndRemove\": \"$PROXIED$\",\n\t\t\t\"findOneAndUpdate\": \"$PROXIED$\",\n\t\t\t\"update\": \"$PROXIED$\",\n\t\t\t\"remove\": \"$PROXIED$\",\n\t\t\t\"count\": \"$PROXIED$\",\n\t\t\t\"geoNear\": \"$PROXIED$\",\n\t\t\t\"geoSearch\": \"$PROXIED$\",\n\t\t\t\"create\": \"$PROXIED$\"\n\t\t},\n\t\t\"paths\": {\n\t\t\t\"title\": {\n\t\t\t\t\"enumValues\": [],\n\t\t\t\t\"regExp\": null,\n\t\t\t\t\"path\": \"title\",\n\t\t\t\t\"instance\": \"String\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"String\",\n\t\t\t\t\t\"required\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": null,\n\t\t\t\t\"isRequired\": true\n\t\t\t},\n\t\t\t\"completed\": {\n\t\t\t\t\"path\": \"completed\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"Boolean\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t},\n\t\t\t\"_id\": {\n\t\t\t\t\"path\": \"_id\",\n\t\t\t\t\"instance\": \"ObjectID\",\n\t\t\t\t\"setters\": [\n\t\t\t\t\t\"not-supported\"\n\t\t\t\t],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"ObjectId\",\n\t\t\t\t\t\"auto\": true\n\t\t\t\t},\n\t\t\t\t\"_index\": null,\n\t\t\t\t\"defaultValue\": \"not-supported\"\n\t\t\t},\n\t\t\t\"__v\": {\n\t\t\t\t\"path\": \"__v\",\n\t\t\t\t\"instance\": \"Number\",\n\t\t\t\t\"setters\": [],\n\t\t\t\t\"getters\": [],\n\t\t\t\t\"options\": {\n\t\t\t\t\t\"type\": \"Number\"\n\t\t\t\t},\n\t\t\t\t\"_index\": null\n\t\t\t}\n\t\t},\n\t\t\"options\": {\n\t\t\t\"id\": true,\n\t\t\t\"noVirtualId\": false,\n\t\t\t\"_id\": true,\n\t\t\t\"noId\": false,\n\t\t\t\"read\": null,\n\t\t\t\"shardKey\": null,\n\t\t\t\"autoIndex\": true,\n\t\t\t\"minimize\": true,\n\t\t\t\"discriminatorKey\": \"__t\",\n\t\t\t\"versionKey\": \"__v\",\n\t\t\t\"capped\": false,\n\t\t\t\"bufferCommands\": true,\n\t\t\t\"strict\": true,\n\t\t\t\"pluralization\": true\n\t\t}\n\t}\n} };\n    \n    AngooseClient.getClass = getClass;\n    AngooseClient.model = getClass;\n    AngooseClient.modelNames = modelNames;\n    AngooseClient.init = init;\r\n    AngooseClient.module = getClass;\n\n}\n\nBootstrapAngoose();     \n\nif (typeof(angoose) == 'undefined'){\n    function angoose(name){\n        return AngooseClient.getClass(name);\n    }\n} \n\n/****** Angular Adapter for Angoose Client *******/\n// Angular client for Angoose automatically register the model and service classes as angular injectables. \n// For instance, with the `SampleUser` model, you can inject in your controller:\n//\n//      angular.module('myapp', ['angoose.client'])\n//            .controller('MyCtroller', function($scope, SampleUser){\n//              $scope.users = SampleUser.$query({'status':'active'});\n//        })      \n//\n(function(){\n    if(typeof angular =='undefined'){\n        console.log(\"No angular\")\n        return;  \n    } \n    console.log(\"##### Angoose Client Loading\");\n    var angularModule =  angular.module(\"angoose.client\", []);\n    AngooseClient.client='angular';\n    \n    // ** angoose **\n    //\n    //  You may require `angoose` client as an injectable\n    //  \n    angularModule.factory('angoose', function($http, $q){\n            var myQ = addDoneMethod($q);\n            AngooseClient.init({\n                http:angularHttpWrapper($http, myQ),\n                promise: myQ\n            });\n            return AngooseClient;\n    })\n    function factoryFunc(modelName){\n        console.log(\"Create factory for model \"+ modelName)\n        angularModule.factory(modelName , function($http, $q, $rootScope, $timeout, angoose){\n            var acModel = AngooseClient.model(modelName);\n            resourceAdapt(acModel, $rootScope, $timeout);\n            return acModel;\n        });\n    }\n    angular.forEach( AngooseClient.modelNames(), factoryFunc );\n\n    function addDoneMethod($q){\n        var myQ = angular.extend({}, $q)\n        myQ.defer = function(){\n            var out = $q.defer.apply($q, arguments);\n            if(out.promise.done) return out;\n            out.promise.done = function(successCallback, errorCallback){\n                out.promise.then(successCallback, errorCallback);\n            }\n            return out;\n        }\n        return myQ;\n    }\n    function angularHttpWrapper($http, $q){\n        var ret = {};\n        ret.post = function(){\n            var deferred = $q.defer();\n            $http.post.apply($http, arguments).success(function(data){\n                deferred.resolve(  data );\n            }).error(function(err){\n                deferred.reject(err);\n            });\n            return deferred.promise;\n        }\n        return ret;\n    }\n    function resourceAdapt(modelClass, $rootScope, $timeout){\n        // now adpat to angular resource\n        modelClass.$get= function(){\n            if(!modelClass.findOne) throw \"Model does not support findOne operation\";\n            var modelInstance = new modelClass();\n            modelClass.findOne.apply(modelClass, arguments).done(function(object){\n                // the return data should be a model instance\n                modelInstance.mergeData(object);\n                //$rootScope.$digest();\n                console.log(\"Copied server data to placeholder\", modelInstance)\n            }, function(err){\n                console.error(\"Unable to load server data\", err);\n            });    \n            \n            return modelInstance;\n        };\n        modelClass.$query=function(){\n            if(!modelClass.find) throw \"Model does not support find operation\";\n            var models = [];\n            modelClass.find.apply(modelClass, arguments).done(function(retModels){\n                // the return data should be a list of models\n                models.length = 0;\n                for(var i=0; retModels && retModels.length>i; i++)\n                    models[i] = retModels[i];\n                //$rootScope.$digest();\n                console.log(\"Copied server data to placeholder\")\n            }, function(err){\n                console.error(\"Unable to load server data\", err);\n            });\n            return models;\n        };\n    }\n})();\n\n// testing functions\nfunction $anget(serviceName){\n    return angular.element(document).injector().get(serviceName)\n}// depdnencies: http, Q\n/****** jQuery plugin for Angoose Client *******/\n(function(){\n    if(AngooseClient.client) return;\n    if(typeof($) == 'undefined' && typeof(jQuery) == 'undefined') return;\n    AngooseClient.client = 'jquery';\n    var $ = $ || jQuery;\n    var $q = typeof(Q) == 'undefined'? createQ() : Q;\n    \n    console.log(\"##### Angoose Client for jQuery Initializing\");\n     AngooseClient.init({\n                http: ajaxHttpWrapper(),\n                promise: $q\n            });\n     function ajaxHttpWrapper( ){\n        var ret = {};\n        ret.post = function(){\n            var deferred = $q.defer();\n            $.post.apply($, arguments).done(function(data, textStatus, jqXHR ){\n                console.log(\"Post return \", data)\n                deferred.resolve(  data );\n            }).fail(function( jqXHR, textStatus, err){\n                deferred.reject(err);\n            });\n            return deferred.promise;\n        }\n        return ret;\n    }\n   \n})();\n\n// testing functions\nfunction $anget(serviceName){\n    return angular.element(document).injector().get(serviceName)\n}\n\n/** include Q for now */\nfunction createQ() {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n\n    function flush() {\n        /* jshint loopfunc: true */\n\n        while (head.next) {\n            head = head.next;\n            var task = head.task;\n            head.task = void 0;\n            var domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n\n            try {\n                task();\n\n            } catch (e) {\n                if (isNodeJS) {\n                    // In node, uncaught exceptions are considered fatal errors.\n                    // Re-throw them synchronously to interrupt flushing!\n\n                    // Ensure continuation if the uncaught exception is suppressed\n                    // listening \"uncaughtException\" events (as domains does).\n                    // Continue in next event to avoid tick recursion.\n                    if (domain) {\n                        domain.exit();\n                    }\n                    setTimeout(flush, 0);\n                    if (domain) {\n                        domain.enter();\n                    }\n\n                    throw e;\n\n                } else {\n                    // In browsers, uncaught exceptions are not fatal.\n                    // Re-throw them asynchronously to avoid slow-downs.\n                    setTimeout(function() {\n                       throw e;\n                    }, 0);\n                }\n            }\n\n            if (domain) {\n                domain.exit();\n            }\n        }\n\n        flushing = false;\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process !== \"undefined\" && process.nextTick) {\n        // Node.js before 0.9. Note that some fake-Node environments, like the\n        // Mocha test runner, introduce a `process` global without a `nextTick`.\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you donb\u0000\u0019t need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millerb\u0000\u0019s explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n// engine that has a deployed base of browsers that support generators.\n// However, SM's generators use the Python-inspired semantics of\n// outdated ES6 drafts.  We would like to support ES6, but we'd also\n// like to make it possible to use generators in deployed browsers, so\n// we also support Python-style generators.  At some point we can remove\n// this block.\nvar hasES6Generators;\ntry {\n    /* jshint evil: true, nonew: false */\n    new Function(\"(function* (){ yield 1; })\");\n    hasES6Generators = true;\n} catch (e) {\n    hasES6Generators = false;\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (isPromise(value)) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become fulfilled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be fulfilled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function(resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function(answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If itb\u0000\u0019s a fulfilled promise, the fulfillment value is nearer.\n * If itb\u0000\u0019s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return isObject(object) &&\n        typeof object.promiseDispatch === \"function\" &&\n        typeof object.inspect === \"function\";\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar unhandledReasonsDisplayed = false;\nvar trackUnhandledRejections = true;\nfunction displayUnhandledReasons() {\n    if (\n        !unhandledReasonsDisplayed &&\n        typeof window !== \"undefined\" &&\n        window.console\n    ) {\n        console.warn(\"[Q] Unhandled rejection reasons (should be empty):\",\n                     unhandledReasons);\n    }\n\n    unhandledReasonsDisplayed = true;\n}\n\nfunction logUnhandledReasons() {\n    for (var i = 0; i < unhandledReasons.length; i++) {\n        var reason = unhandledReasons[i];\n        console.warn(\"Unhandled rejection reason:\", reason);\n    }\n}\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n    unhandledReasonsDisplayed = false;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n\n        // Show unhandled rejection reasons if Node exits without handling an\n        // outstanding rejection.  (Note that Browserify presently produces a\n        // `process` global without the `EventEmitter` `on` method.)\n        if (typeof process !== \"undefined\" && process.on) {\n            process.on(\"exit\", logUnhandledReasons);\n        }\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n    displayUnhandledReasons();\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    if (typeof process !== \"undefined\" && process.on) {\n        process.removeListener(\"exit\", logUnhandledReasons);\n    }\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n            if (hasES6Generators) {\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return result.value;\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return exception.value;\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var countDown = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++countDown;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--countDown === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (countDown === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {String} custom error message (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, message) {\n    return Q(object).timeout(ms, message);\n};\n\nPromise.prototype.timeout = function (ms, message) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        deferred.reject(new Error(message || \"Timed out after \" + ms + \" ms\"));\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n}/** Angoose Client for Node.js */\n\n(function(){\n    if(typeof exports ==\"undefined\" || typeof require == 'undefined') return;\n    console.log(\"##### Angoose node client Loading\");\n    var Q  = require(\"q\");\n    AngooseClient.init({\n        //http: realHttp(),\n        http:mockHttp(),\n        promise:Q\n    });\n    \n    function realHttp(){\n        var request = require('request');\n        var _ = require(\"underscore\")\n        var HTTP_BASE =  \"http://localhost:9988\"; // +( AngooseClient.configs.httpPort ?(\":\"+ AngooseClient.config.httpPort):\"\");\n        var $httpDelegate = {}\n        var methods = ['get', 'post','put','delete'];\n        // create deletage functions over request module\n        var createFunc = function(method){\n            return function(url, data, callback){\n                console.log(\"Sending thtp request\", url)\n                var options = {url:  HTTP_BASE + url, method:method, jar:true , json:true};\n                if(data && typeof(data) != 'function' ) \n                    options.json = data;\n                else{\n                    callback = data;\n                } \n                var deferred = Q.defer();\n                request(options, function(err, res, body){\n                    if(err) \n                        deferred.reject(new Error(err));\n                    else\n                        deferred.resolve(body);\n                    if(callback) callback(err, body);\n                });\n                return deferred.promise;\n            }\n        }\n        _.each(methods, function(method){\n            $httpDelegate[method] = createFunc(method);\n        })\n        return $httpDelegate;\n           \n    }\n    function mockHttp(){\n        var httpMock = require(\"node-mocks-http\");\n        var mock = {};\n        var session = {};\n        mock.post = function(url, data){\n            var deferred = Q.defer();\n            \n            var request= httpMock.createRequest({\n                    url: url,\n                    method:'POST',\n                    params: {\n                        method: data.method,\n                        model: data.clazz\n                    }, \n                    session:session\n            });\n            request.body = data;\n            var mockUser = {\n                    _id: '52c44dd0ecafbf1a9a000002',\n                    username:'Gaelyn',\n                    email:'gaelyn@demo.com',\n                    roles:'admin',\n                    type:'admin'\n               }\n            // /** session */\n           // request.session = {\n               // user: mockUser,\n               // userObj: mockUser\n           // }\n           var response = httpMock.createResponse();\n           response.send = function(code, data){\n               data = JSON.parse( JSON.stringify(data) );\n               deferred.resolve(data);\n           }\n           var ROOT = process.cwd();\n           var angoose = null;\n           if(require(\"fs\").existsSync(ROOT+\"/lib/angoose.js\"))\n                angoose = require(ROOT+\"/lib/angoose\");\n           else {\n                angoose = require(\"angoose\");\n           }\n               \n           \n           angoose.rmiAccept(request, response);\n           return deferred.promise;\n        }\n        return mock    \n    }\n\n    module.exports = AngooseClient;         \n})()\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/debugger.js":"var ROOT=process.cwd();\nconsole.log(ROOT);\n\nrequire(ROOT+\"/server/util/angoose-setup\")();\n\nvar mongoose = require(\"mongoose\");\n\nvar User = mongoose.model('User');\nvar Physician = mongoose.model('Physician');\nUser.findById('5296b80a888bfd8f05000008', function(err, user){\n    console.log(\"user\", user)\n    console.log(\"User is user\", user instanceof User);\n    console.log(\"User is physician\", user instanceof Physician);\n})\n\n\n\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/extensions/angoose-authorization.js":"var angoose = require(\"../lib/angoose\");\nvar toolbox = require(\"../lib/util/toolbox\");\n\nvar EXTENSION = 'angoose-authorization';\nvar MODEL_NAME  = 'PermissionModel';\nvar COLLECTION_NAME  = 'angoose_perms';\n\nvar cached = null;\nvar authExt = {\n    name: EXTENSION,\n    preAuthorize: preAuth,\n    postAuthorize: postAuth,\n    preRedact: redact,\n    postInvoke: postInvoke,\n    beforeCreateBundle: beforeCreateBundle\n};\n\nmodule.exports = angoose.extension('AngooseAuthorization',  authExt);\n\nfunction preAuth(next){\n    logger().trace(\"in preAuth\", session().$authenticatedUser);\n    var authUser = session().$authenticatedUser;\n    if(authUser){\n        logger().trace(\"Found user in session\",    authUser);\n        //angoose.getContext().setUser( session().$authenticatedUser );\n        angoose.getContext().setPrincipal( new angoose.Principal( authUser.userId, authUser.roles) );\n    }  \n    else{\n        angoose.getContext().setPrincipal( new angoose.Principal( 'guest', 'guest' ));\n    }\n    next();\n};\nfunction logger(){\n    var extensionOptions = angoose.config()[EXTENSION] ;\n    angoose.getLogger('angoose-authorization').setLevel((extensionOptions && extensionOptions.logging) || 'INFO');\n    return angoose.getLogger('angoose-authorization')\n}\nfunction postAuth(next, invocation){\n   var extensionOptions = angoose.config()[EXTENSION]  ;\n   \n   var ctx = angoose.getContext();\n   var user = ctx.getPrincipal();\n   \n   invocation.allowed = true;\n   \n   /** admin user bypass */\n   var superuser =  extensionOptions && extensionOptions.superuser \n   if(user.getUserId() ===  superuser ) return next(); // always allow super user admin\n   var superrole = ( extensionOptions && extensionOptions.superrole ) || 'admin';\n   if(user && user.getRoles().indexOf(superrole) >=0) return next();\n   \n   logger().trace(\"in auth.postAuth:\", invocation.clazz, invocation.method);\n   if(invocation.method == 'signin' || invocation.method==\"signout\") return next();\n\n   var mod = angoose.module( invocation.clazz );\n   var category = mod.config(EXTENSION +\".category\") || invocation.clazz;\n   var group = toolbox.camelcase(getGroup(mod, invocation.method)) || invocation.method;\n   \n    var roles = user.getRoles() ? user.getRoles(): [];\n    roles = Array.isArray(roles)? roles: [ roles ];\n    if(roles.indexOf('guest') <0) roles.push('guest');\n    if(roles.indexOf('authenticated') <0) roles.push('authenticated');\n   \n   var allowed = isAllowed( category +\".\"+ group, roles, function(allowed){\n        logger().trace(\"isAllowed: \", category, group, allowed);\n        invocation.allowed = allowed;\n        next();    \n   });\n};\n// redaction\nfunction redact(next){\n    logger().trace(\"in auth.preRedact\"); \n    next();\n};\nfunction isAllowed(action, roles, callback){\n    logger().trace(\"Checking \", roles, \" for action\", action);\n    getMatrix(function(perms){\n        for(var i=0;i<roles.length;i++){\n            var permissions =  perms &&  perms[ roles[i] ];\n            if(permissions && permissions.get( action )  === true ) return callback(true);\n        };\n        callback(false); \n    });\n}\n\n\nfunction getMatrix(callback){\n    if(cached){\n        return callback(cached);\n    }\n    angoose(MODEL_NAME).find(function(err, perms){\n        if(err) logger().error(\"Failed to load permission roles\", err);\n        cached = {};\n        for(var i=0; perms && i<perms.length; i++){\n            var perm = perms[i];\n            cached[perm.role] = perm;\n        }\n        callback(cached);\n    });    \n}\nfunction schemaInterceptor(next,  schema){  // shouldn't the err argument be here? \n    //console.log(\"in post prepareSchema\",schema);\n    if(schema && (schema.methods || schema.statics) ){\n        var methodNames = (schema.methods && Object.keys(schema.methods)) || [];\n        methodNames.concat( (schema.statics && Object.keys(schema.statics)) || []);\n        for(var i=0;methodNames && i<methodNames.length;i++){\n           var mName = methodNames[i];  \n           var path = schema.moduleName +\".\" + mName;\n           var opts = {path: path, options:{type:'Boolean'} };\n           authItems[path] = opts;  \n        };\n    };\n    next(null, schema);  // we shouldn't need to provide the arguments here, bug in hooks module?\n};\n\nfunction getGroup(module, methodName){\n     var configPath = EXTENSION+\".\"+methodName+\".group\";\n     var grp =  module.config(configPath) || \"\"\n     if(!grp && isModel(module)){\n         //populate,find,findOne,findById,findByIdAndRemove,findByIdAndUpdate,findOneAndRemove,findOneAndUpdate,update,remove,count,geoNear,geoSearch,aggregate\n         // mongoose groups:  View, Modify, Create, Remove\n         if('populate,find,findOne,findById,geoNear,geoSearch,aggregate,count,'.indexOf(methodName)>=0) return 'View';\n         if('update,save'.indexOf(methodName  )>=0) return 'Modify';\n         if('remove'.indexOf(methodName )>=0) return 'Delete';\n         if('create'.indexOf(methodName  )>=0) return 'Create';\n         if('findByIdAndRemove,findByIdAndUpdate,findOneAndRemove,findOneAndUpdate'.indexOf(methodName) >=0) return \"find-and-modify\"\n     }\n     return grp\n}\nfunction getLabel(module, methodName){\n    var configPath = EXTENSION+\".\"+methodName+\".label\";\n    return module.config(configPath) || toolbox.camelcase(methodName, true)\n}\nfunction getCategory(module){\n    var configPath = EXTENSION+\".category\";\n    return module.config(configPath) || module.config('name');\n}\nfunction isModel(module){\n    return module.config('baseClass') == 'Model';\n}\nfunction beforeCreateBundle(  client){\n    // generating PermissionModel schema used on UI\n    logger().debug(\"in beforeCreateBundle\"); \n    MODEL_NAME = angoose.config('angoose-authorization.model-name') || MODEL_NAME;\n    COLLECTION_NAME = angoose.config('angoose-authorization.collection-name') || COLLECTION_NAME;\n    \n    var schemas = client.schemas;\n    var authSchema = getModelSchema(); \n    // get list of all published methods\n    Object.keys(schemas).forEach(function(moduleName){\n        var schema = schemas[moduleName];\n        if(!schema || moduleName == 'SampleUser') return;\n        var methodNames =   Object.keys(schema.methods).concat(Object.keys(schema.statics));\n        var mod = angoose.module(moduleName);\n        if(mod.config && mod.config(\"visibility\") === false ) return;\n        var category = getCategory(mod);\n        for(var i=0;methodNames && i<methodNames.length;i++){\n           var mName = methodNames[i];\n           if(mName == 'config' || mName == 'getSchema') continue;\n           var fn = schema.methods && schema.methods[mName];\n           fn = fn || (schema.statics && schema.statics[mName]);\n           if(toolbox.methodType(fn) != 'remote') continue; \n           \n           var group = getGroup(mod, mName);\n           if(!group){\n               var path = category +\".\" + mName;\n               var field = {};\n               field[path] = {type:Boolean, label: getLabel(mod,mName)};\n               authSchema.add(field);    \n           }\n           else if(!authSchema.path(group)){\n               // add schema path for the permission group\n               var path = category +\".\" +  toolbox.camelcase(group);\n               var field = {};\n               field[path] = {type:Boolean, label: toolbox.camelcase(group, true)};\n               authSchema.add(field);   \n           }\n        };\n    });\n    var mongooseModel =  angoose.getMongoose().modelNames().indexOf(MODEL_NAME)>=0? angoose.getMongoose().model(MODEL_NAME):angoose.getMongoose().model(MODEL_NAME, authSchema) ;\n    var permModule = angoose.module(MODEL_NAME, mongooseModel); \n    new angoose.Bundle().exportModule(client, MODEL_NAME); // toolbox.exportModuleMethods(MODEL_NAME, permModule);\n    logger().debug(\"Added mongoose model\", MODEL_NAME);\n    \n    setupInitialRoles();\n};\n\nfunction postInvoke(next, invocation){\n    // this is bizzare, if main method fails, this will be called with arguments meant for pre()\n    //var invocation = angoose.getContext().getInvocation(); \n    if( ['signin', 'signout'].indexOf(invocation.method ) <0 ) return next();;\n    \n    if(invocation.method == 'signout'){\n        if(angoose.getContext().getRequest().session)\n            angoose.getContext().getRequest().session.$authenticatedUser =   null;\n        logger().debug(\"User logged out\");\n    }\n    var data = invocation.result;\n    logger().debug(\"Intercepting login methods\", invocation.method, data);\n    if(!data || !data.userId  )\n        return next();;\n    if(invocation.method == 'signin'){\n        angoose.getContext().getRequest().session.$authenticatedUser =   {userId: data.userId, roles: data.roles } ;\n        logger().debug(\"User authenticated\", angoose.getContext().getRequest().session.$authenticatedUser );\n    }\n    next();    \n};\n\nfunction moduleSetup(next){\n    next();    \n} \n\nfunction session(){\n     return angoose.getContext().getRequest().session || {};\n};\n\nfunction getModelSchema(){\n    var schema =  new angoose.getMongoose().Schema({\n         role: {type:String, label:'Role', required:true, tags:['default-list'], unique:true },\n         desc: {type:String, label:'Description',tags:['default-list']}\n    }, {collection: COLLECTION_NAME});\n    \n    schema.pre('save', function(next){\n       cached =  null; // invalidate the cache\n       next(); \n    });\n    \n    return schema;\n}\n\n\nfunction setupInitialRoles(){\n    var model=  angoose.module(MODEL_NAME);\n    model.findOne({role:'admin'}, function(err, role){\n        if(role) return;\n        var u = new model({\n            role:'admin', \n            desc:\"System default role with all permissions\"\n        });\n        u.save(function(err){\n            logger().debug(\"Added default role: admin\");\n        });\n    });\n    model.findOne({role:'authenticated'}, function(err, role){\n        if(role) return;\n        var u = new model({\n            role:'authenticated', \n            desc:\"System default role for authenticated user\"\n        });\n        u.save(function(err){\n            logger().debug(\"Added default role: authenticated\");\n        });\n    });\n    \n     model.findOne({role:'guest'}, function(err, role){\n        if(role) return;\n        var u = new model({\n            role:'guest', \n            desc:\"System default role for guest user\"\n        });\n        u.save(function(err){\n            logger().debug(\"Added default role: guest\");\n        });\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/extensions/angoose-mongoose.js":"var angoose = require(\"../lib/angoose\");\nvar toolbox = require(\"../lib/util/toolbox\");\nvar EXTENSION = 'angoose-mongoose';\nvar path= require(\"path\"),traverse = require(\"traverse\"),hooks= require(\"hooks\"), Q = require(\"q\");\nvar fs = require(\"fs\"),  _ =require(\"underscore\");\n\ntoolbox.patchMongoCallback();\n\nvar plugin = {\n    postResolveTarget: postResolveTarget,\n    postInvoke: postInvoke,\n    postPack: postPack,\n    postExportModule: decorateMongooseSchema,\n    afterFormatError: formatError\n};\nmodule.exports = angoose.extension('MongooseExtension', plugin);\n\nfunction formatError(next, invocation){\n    var ex = invocation.packed.exception;\n    console.log(\"Intercepting error\", ex);\n    // check if it's mongoose's model error\n    var errors = toolbox.getter(ex , 'cause.errors');\n    if( errors){\n        // format model error\n        var msg = '';\n        Object.keys(errors).forEach(function(key){\n            var errobj = errors[key];\n            var m = errobj.message+\"\";\n            msg = msg+m+\" \" \n        });\n        ex.message = msg;\n    }\n    next();\n};\n\nfunction decorateMongooseSchema(  client, moduleName){\n    var model = angoose.module(moduleName);\n    if(!model.schema || !model.schema.paths) return;\n    logger().trace(\"Decorating mongoose model\", moduleName);\n    \n    var schema = client.schemas[moduleName];\n    // automatically publish these instance methods\n    var instanceMethods = \"save,remove,populate\";\n    instanceMethods.split(\",\").forEach(function(m){\n        m = m.replace(/\\s+/g, '');\n        if(!schema.methods[m]) \n            schema.methods[m]= function remote(){};     \n    });\n    \n    // automatically publish these static methods\n    var staticMethods = \"populate,find,findOne,findById,findByIdAndRemove,findByIdAndUpdate,findOneAndRemove,findOneAndUpdate,update,remove,count,geoNear,geoSearch,create\";\n    staticMethods.split(\",\").forEach(function(m){\n        m = m.replace(/\\s+/g, '');\n        if(!schema.statics[m])\n            schema.statics[m]= function remote(){};     \n    });\n    \n    schema.paths = traverse(model.schema.paths).map(function(item){\n        if(!item) return;\n        if(item.options && typeof(item.options.type) === 'function' ){\n            var fn = item.options.type;\n            item.options.type = fn.name || fn.toString();                \n        }\n        else if(typeof(item) == 'function')\n            this.update( 'not-supported' );\n        if(item.requiredValidator) delete item.requiredValidator;\n        if(item.enumValidator) delete item.enumValidator;\n        if(item.validators) delete item.validators; /**@todo validators are not supported yet*/\n    }); \n    schema.options = traverse( model.schema.options).clone();\n//    filtPaths(schema);\n}\nfunction filtPaths(schema){\n    traverse(schema).forEach(function(item){\n        if((this.parent&&this.parent.parent&&this.parent.parent.key=='paths')\n                ||(this.parent&& (this.parent.isRoot || this.parent.key == 'schema')))\n        {\n            if(_.indexOf(['moduleName','methods','statics','paths','enumValues','isRequired','schema','caster','path','options','instance'],this.key)<0){\n                this.remove();\n            }\n        }\n    })\n}\n\nfunction logger(){\n    var logger = angoose.getLogger('angoose'); return logger;\n}\n\nfunction postResolveTarget(next, invocation){\n    if(!invocation.target || invocation.static || ! invocation.instance || !invocation.instance._id ) return next();\n    logger().debug(\"postResolveTarget for mongoose models\");\n        \n    var _id = invocation.instance._id;\n    logger().trace(\"Loading pristine instance as base\",invocation.clazz, _id);\n    var modelClass = angoose.module(invocation.clazz);\n    modelClass.findById(_id,   function mongoCallback(err, pristineInstance){\n       if(err || !pristineInstance){\n           logger().error(\"Failed to load model by id\", _id);\n           return next(err);\n       }\n       var pristineObject = pristineInstance.toObject();\n       var schema = modelClass.schema;\n       Object.keys(schema.paths).forEach(function(path){\n           if (/^_/.test(path)) return;\n           //var pathSchema = schema.paths[path];\n           //var ref = schemaUtil.getReference(pathSchema);\n           if (/^_/.test(path)) return;\n           var newVal = toolbox.getter(invocation.instance, path);\n           var oldVal  =  toolbox.getter(pristineObject, path); \n           if(!_.isEqual(oldVal, newVal) &&  newVal !==  undefined ){ /**@todo: empty value from client side doesn't mean set to empty, need to implement the $dirty, modified' */\n                if(newVal == '$CLEAR$') newVal = null;\n                pristineInstance.set(path,newVal);\n                logger().trace(\"seting\", path, \": \",oldVal, \" --> \", newVal, \" NOW dirty? \",  pristineInstance.isModified(path));\n           }\n       });\n       invocation.target = pristineInstance;\n       next();\n    });\n}\n\nfunction postInvoke (next, invocation){\n    var result = invocation.result;\n    \n    if(result && result.exec && (result instanceof angoose.getMongoose().Query) ){ // mongoose promise\n        logger().debug(\"Return is mongoose query, call exec(). Conditions: \", result._conditions );\n        result.exec( function(err, ret){\n            if(err) return next(err);\n            invocation.result = ret;\n            next();    \n        });\n        return;\n    }\n    \n    function checkForModelError(result ){\n        var target = invocation.static ? null : invocation.target;\n        var err = ( target && target.errors) || (result && result.errors);\n        if(err)\n        {\n            // temp error handling\n            var msg = ''; \n            Object.keys(err).forEach(function (errItem) {\n                msg += ex.message?\"; \":\"\";\n                msg += err[errItem].message; \n            })\n            msg = msg || err.toString();\n            return msg; \n        }\n    }\n    \n    process.nextTick(function waitForModelError(){\n        /** the model error is emitted in next tick */\n        var ex = checkForModelError(result);\n        if(ex){\n            logger().debug(\"Detected model error\", ex);\n            return next(ex);\n        } \n        next();  \n    });\n      \n}; /**  end invoke */\n\nfunction postPack(next, invocation){\n    //console.log(\"In mongoose post pack\", invocation)\n    if(!invocation.redacted) return next();\n    var type = getValueType(invocation.redacted);\n    if(type) invocation.packed.datatype = type;\n    next();\n}\n \nfunction getValueType(obj){\n    if( obj.schema && obj.schema.paths && obj.schema.methods ) return 'model';\n    if(Array.isArray( obj )){\n        if(obj.length && getValueType(obj[0]) == 'model') return \"models\";\n    }\n    return null;\n}\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/models/SampleService.js":"var angoose = require(\"../lib/angoose\");\nvar Q = require(\"q\");\nvar SampleService =  function(){};\nSampleService.listFavoriteDestinations= function(){\n        return [\"Paris\", \"Virgin Islands\", \"Antarctic\"]\n    }\nSampleService.testExecutionContext= function remote($callback){\n        var self = this;\n        var su = require(\"./SampleUser\");\n        su.findOne(angoose.bind(   function(err, res){\n                var ctx = self.getContext();\n                console.log(\"In testExecutionContext \"+ ctx.seqnum)\n                var req = ctx.getRequest();\n                $callback(false, req.params['method']);\n        }))\n}\n// static method\nSampleService.testPromiseReturn=function(){\n    console.log(\"testPromiseReturn!\");\n    var out = Q.defer();\n    out.resolve(\"PromiseOK\");\n    process.nextTick(function(){\n        out.resolve(\"PromiseOK\");\n    })\n    return out.promise;\n}\n\nSampleService.testErrorBack = function($callback){\n    console.log(\"In testErrorCallback\");\n    $callback(\"Error in testError\");\n} \nmodule.exports = angoose.module('SampleService',  SampleService);\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/models/SampleUser.js":"var angoose = require(\"../lib/angoose\");\nvar mongoose = angoose.getMongoose();\nvar SampleSchema = mongoose.Schema({\n        email:  {type: String, required: true, match: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i, unique:true},\n        firstname: {type: String, required:true },\n        lastname: {type: String, required:true },\n        status: {type: String, enum: ['inactive', 'active', 'disabled', 'archived'], required:true, def:'inactive' },\n        password: { type:String },\n        verified: Boolean,\n        groupRef: {type: mongoose.Schema.Types.ObjectId, ref: 'SampeUserGroup'}\n    },\n    {\n        collection:'SampleUsers', \n        discriminatorKey: 'type'\n    }\n);\nvar sampleUserData = { \n    firstname:'Gaelyn', \n    lastname:'Hurd',\n    status:'active',\n    email: 'gaelyn@hurd.com',\n};\n\nSampleSchema.methods.getFullname= function portable(){\n    //_instance_portable\n    console.log(\"getFullname\", this);\n    return  (this.firstname ? this.firstname +\" \": \"\") + (this.lastname || \"\");\n}\nSampleSchema.methods.setPassword= function(newPassword, $context, $callback){\n    // instance method, reset user's password.\n    if(!$callback ) throw \"$callback not injected\";\n    if(!$context) throw \"$context not injected\";\n    //var cryptor = require(\"crypto\"); // require node module crypto\n    //this.password = cryptor.encrypt(\"salt\", newPassword);\n    this.password  = newPassword +\"salt123\"; // fake code\n    $callback(false, \"Password changed\");\n}\nSampleSchema.statics.getSample = function(){\n    // this should refer to the model class\n    console.log(\"get sample user\");\n    var instance = new this( sampleUserData); \n    return instance;\n    \n}\nSampleSchema.statics.checkExists = function(email){\n    //_static_remote\n    console.log(\"in checkExists\",email);\n    require(\"fs\");  // do a server side operation to ensure this can only be done in the server side.\n    if(email && email.indexOf('new')>=0) return false;\n    return true;\n}\nvar SampleUser = mongoose.model('SampleUser', SampleSchema);\nmodule.exports = SampleUser;\n\nSampleSchema.path('email').validate(function(value, respond){\n    if(value && value.indexOf(\".org\")>0){\n        process.nextTick(function(){\n            respond(false)    \n        })\n    }\n    else\n        respond(true);\n}, \"I don't like .org emails\")\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/models/SampleUserGroup.js":"var mongoose = require('mongoose');\nvar SampleSchema = mongoose.Schema({\n        name:  {type: String, required: true, unique:true},\n        description:  {type: String }\n    },\n    {\n        collection:'SampleGroups'\n    }\n);\n \nvar SampleUserGroup = mongoose.model('SampleUserGroup', SampleSchema);\nmodule.exports = SampleUserGroup;\n\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/models/Todo.js":"var angoose = require(\"../lib/angoose\"); /** if angoose is installed as module, then require('angoose')*/\nvar mongoose = angoose.getMongoose();\nvar todoSchema = mongoose.Schema({\n       title: { type: String, required: true},\n       completed: Boolean\n    });  \nmodule.exports = mongoose.model('Todo', todoSchema);\n","/home/travis/build/npmtest/node-npmtest-angoose/node_modules/angoose/public/todo-angular-app.js":"'use strict';\n\n/**\n * The main TodoMVC app module\n *\n * @type {angular.Module}\n */\nvar todomvc = angular.module('todomvc', ['ngRoute', 'angoose.client']).config(['$routeProvider','$locationProvider', function($routeProvider, $locationProvider) {\n    $routeProvider.when('/:selectedStatus?', {templateUrl:'todomvc-index.html', controller: 'TodoCtrl'})\n    \n     $locationProvider.html5Mode(true);\n}]);\n\n/** controller */\ntodomvc.controller('TodoCtrl', function TodoCtrl($scope, $location, Todo, filterFilter, $routeParams) {\n        var todos = $scope.todos = Todo.$query();\n    \n        $scope.status = '';\n    \n        $scope.newTodo = '';\n        $scope.remainingCount = filterFilter(todos, {completed: false}).length;\n        $scope.editedTodo = null;\n\n        if ($location.path() === '') {\n                $location.path('/');\n        }\n\n        $scope.location = $location;\n\n        $scope.$watch('status', function (status) {\n                $scope.statusFilter = { 'active': {completed: false}, 'completed': {completed: true} }[status];\n        });\n\n        $scope.$watch('remainingCount == 0', function (val) {\n                $scope.allChecked = val;\n        });\n\n        $scope.addTodo = function () {\n                var newTodo = $scope.newTodo.trim();\n                if (newTodo.length === 0) {\n                        return;\n                }\n\n                var todo = new Todo({\n                        title: newTodo,\n                        completed: false\n                });\n                todo.save(function(err,res){\n                    if(err) return alert(err);\n                    \n                    todos.push(todo);\n                    $scope.newTodo = '';\n                    $scope.remainingCount++;    \n                });\n        };\n\n        $scope.editTodo = function (todo) {\n                $scope.editedTodo = todo;\n        };\n\n        $scope.doneEditing = function (todo) {\n                $scope.editedTodo = null;\n                todo.title = todo.title.trim();\n\n                if (!todo.title) {\n                        $scope.removeTodo(todo);\n                }\n                todo.save(function(err, res){\n                    if(err) alert(err);  \n                })\n        };\n\n        $scope.removeTodo = function (todo) {\n                $scope.remainingCount -= todo.completed ? 0 : 1;\n                todo.remove(function(err, res){\n                    todos.splice(todos.indexOf(todo), 1);    \n                });\n        };\n\n        $scope.todoCompleted = function (todo) {\n                $scope.remainingCount += todo.completed ? -1 : 1;\n                todo.save();\n        };\n\n        $scope.clearCompletedTodos = function () {\n                angular.forEach(todos, function(todo){\n                    if(todo.completed)  \n                        todo.remove();\n                });\n        };\n\n        $scope.markAll = function (completed) {\n                todos.forEach(function (todo) {\n                        todo.completed = !completed;\n                        todo.save();\n                });\n                $scope.remainingCount = completed ? 0 : todos.length;\n                //todoStorage.put(todos);\n        };\n});\n"}